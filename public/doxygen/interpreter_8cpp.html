<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EARL: interpreter.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EARL<span id="projectnumber">&#160;0.0.3</span>
   </div>
   <div id="projectbrief">An interpreted scripting language.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">interpreter.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;variant&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &quot;<a class="el" href="parser_8hpp_source.html">parser.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utils_8hpp_source.html">utils.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="interpreter_8hpp_source.html">interpreter.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="intrinsics_8hpp_source.html">intrinsics.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="err_8hpp_source.html">err.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="token_8hpp_source.html">token.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ast_8hpp_source.html">ast.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ctx_8hpp_source.html">ctx.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="common_8hpp_source.html">common.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="earl_8hpp_source.html">earl.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lexer_8hpp_source.html">lexer.hpp</a>&quot;</code><br />
</div>
<p><a href="interpreter_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPackedERPreliminary.html">PackedERPreliminary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9848987fdf8a319ce15dca506de1e360"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a9848987fdf8a319ce15dca506de1e360">eval_stmt_let</a> (<a class="el" href="structStmtLet.html">StmtLet</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a9848987fdf8a319ce15dca506de1e360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d92337c12e776348ff89e45479736ab"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a3d92337c12e776348ff89e45479736ab">eval_stmt_def</a> (<a class="el" href="structStmtDef.html">StmtDef</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a3d92337c12e776348ff89e45479736ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c23ff9e06216e2784ea26cb43276c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInterpreter_1_1ER.html">ER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a7d8c23ff9e06216e2784ea26cb43276c">eval_expr_term_mod_access</a> (<a class="el" href="structExprModAccess.html">ExprModAccess</a> *expr, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx, bool ref)</td></tr>
<tr class="separator:a7d8c23ff9e06216e2784ea26cb43276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4434dda3007accc915f304f1f1573d84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInterpreter_1_1ER.html">ER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a4434dda3007accc915f304f1f1573d84">eval_expr_term_get</a> (<a class="el" href="structExprGet.html">ExprGet</a> *expr, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx, bool ref)</td></tr>
<tr class="separator:a4434dda3007accc915f304f1f1573d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbdac6fbb302ccc83bee9af8fa851eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInterpreter_1_1ER.html">ER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a6cbdac6fbb302ccc83bee9af8fa851eb">eval_expr_term</a> (<a class="el" href="structExprTerm.html">ExprTerm</a> *expr, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx, bool ref)</td></tr>
<tr class="separator:a6cbdac6fbb302ccc83bee9af8fa851eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c985b8b2b9b544f21563c42933237f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInterpreter_1_1ER.html">ER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#ab4c985b8b2b9b544f21563c42933237f">eval_expr_bin</a> (<a class="el" href="structExprBinary.html">ExprBinary</a> *expr, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx, bool ref)</td></tr>
<tr class="separator:ab4c985b8b2b9b544f21563c42933237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdefe66e021e5f78f55d17a893aeb7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInterpreter_1_1ER.html">ER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a6bdefe66e021e5f78f55d17a893aeb7a">eval_expr_unary</a> (<a class="el" href="structExprUnary.html">ExprUnary</a> *expr, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx, bool ref)</td></tr>
<tr class="separator:a6bdefe66e021e5f78f55d17a893aeb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfae56204f9742efb8fa8f4f58e2b061"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#abfae56204f9742efb8fa8f4f58e2b061">eval_stmt_let_wmultiple_vars</a> (<a class="el" href="structStmtLet.html">StmtLet</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:abfae56204f9742efb8fa8f4f58e2b061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8fe0301baaa20a2e89b4164228c88b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#abb8fe0301baaa20a2e89b4164228c88b">eval_stmt_expr</a> (<a class="el" href="structStmtExpr.html">StmtExpr</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:abb8fe0301baaa20a2e89b4164228c88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701c83cda284bfe8534e9a9efa65cf23"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a701c83cda284bfe8534e9a9efa65cf23">eval_stmt_if</a> (<a class="el" href="structStmtIf.html">StmtIf</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a701c83cda284bfe8534e9a9efa65cf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1324d385847c4f361260ce4f5768fd0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#af1324d385847c4f361260ce4f5768fd0">eval_stmt_return</a> (<a class="el" href="structStmtReturn.html">StmtReturn</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:af1324d385847c4f361260ce4f5768fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73292a1e2fa4be29c99882080f90287c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a73292a1e2fa4be29c99882080f90287c">eval_stmt_break</a> (<a class="el" href="structStmtBreak.html">StmtBreak</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a73292a1e2fa4be29c99882080f90287c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4757dd52050c9af9135d49de45098eed"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a4757dd52050c9af9135d49de45098eed">eval_stmt_mut</a> (<a class="el" href="structStmtMut.html">StmtMut</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a4757dd52050c9af9135d49de45098eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5b83c404a3fc36587fcb97d9e0e228"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a0b5b83c404a3fc36587fcb97d9e0e228">eval_stmt_while</a> (<a class="el" href="structStmtWhile.html">StmtWhile</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a0b5b83c404a3fc36587fcb97d9e0e228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee321cdf1b8fb41e2d8ab35fd9475d3c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#aee321cdf1b8fb41e2d8ab35fd9475d3c">eval_stmt_foreach</a> (<a class="el" href="structStmtForeach.html">StmtForeach</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:aee321cdf1b8fb41e2d8ab35fd9475d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9354fc46ec4c0a84eac595508cc952ed"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a9354fc46ec4c0a84eac595508cc952ed">eval_stmt_for</a> (<a class="el" href="structStmtFor.html">StmtFor</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a9354fc46ec4c0a84eac595508cc952ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab562db9e7f7a90900f8bb9da700970"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a3ab562db9e7f7a90900f8bb9da700970">eval_stmt_class</a> (<a class="el" href="structStmtClass.html">StmtClass</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a3ab562db9e7f7a90900f8bb9da700970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c949702d10c60c678d744b95b88a767"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a9c949702d10c60c678d744b95b88a767">eval_stmt_mod</a> (<a class="el" href="structStmtMod.html">StmtMod</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a9c949702d10c60c678d744b95b88a767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6759312e77eec73ab603ae88ce11f4d8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a6759312e77eec73ab603ae88ce11f4d8">eval_stmt_import</a> (<a class="el" href="structStmtImport.html">StmtImport</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a6759312e77eec73ab603ae88ce11f4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e863f678741d0d724b4a384c5e2c9f6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interpreter_8cpp.html#a3e863f678741d0d724b4a384c5e2c9f6">eval_stmt_match</a> (<a class="el" href="structStmtMatch.html">StmtMatch</a> *stmt, std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;ctx)</td></tr>
<tr class="separator:a3e863f678741d0d724b4a384c5e2c9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab4c985b8b2b9b544f21563c42933237f" name="ab4c985b8b2b9b544f21563c42933237f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c985b8b2b9b544f21563c42933237f">&#9670;&nbsp;</a></span>eval_expr_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInterpreter_1_1ER.html">ER</a> eval_expr_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structExprBinary.html">ExprBinary</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01469">1469</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1469</span>                                                                   {</div>
<div class="line"><span class="lineno"> 1470</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> lhs = Interpreter::eval_expr(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#addee8cd71ed68a4f7de12a8d32b8a34a">m_lhs</a>.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1471</span>    <span class="keyword">auto</span> lhs_value = unpack_ER(lhs, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1472</span> </div>
<div class="line"><span class="lineno"> 1473</span>    <span class="comment">// Short-circuit evaluation for logical AND (&amp;&amp;)</span></div>
<div class="line"><span class="lineno"> 1474</span>    <span class="keywordflow">if</span> (expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>-&gt;type() == TokenType::Double_Ampersand) {</div>
<div class="line"><span class="lineno"> 1475</span>        <span class="comment">// If lhs is false, return lhs (no need to evaluate rhs)</span></div>
<div class="line"><span class="lineno"> 1476</span>        <span class="keywordflow">if</span> (!lhs_value-&gt;boolean())</div>
<div class="line"><span class="lineno"> 1477</span>            <span class="keywordflow">return</span> lhs;</div>
<div class="line"><span class="lineno"> 1478</span>        <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> rhs = Interpreter::eval_expr(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#af25c8b843f3285e21b04de0eadf92908">m_rhs</a>.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1479</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(unpack_ER(rhs, ctx, ref), ERT::Literal);</div>
<div class="line"><span class="lineno"> 1480</span>    }</div>
<div class="line"><span class="lineno"> 1481</span> </div>
<div class="line"><span class="lineno"> 1482</span>    <span class="comment">// Short-circuit evaluation for logical OR (||)</span></div>
<div class="line"><span class="lineno"> 1483</span>    <span class="keywordflow">if</span> (expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>-&gt;type() == TokenType::Double_Pipe) {</div>
<div class="line"><span class="lineno"> 1484</span>        <span class="comment">// If lhs is true, return lhs (no need to evaluate rhs)</span></div>
<div class="line"><span class="lineno"> 1485</span>        <span class="keywordflow">if</span> (lhs_value-&gt;boolean())</div>
<div class="line"><span class="lineno"> 1486</span>            <span class="keywordflow">return</span> lhs;</div>
<div class="line"><span class="lineno"> 1487</span>        <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> rhs = Interpreter::eval_expr(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#af25c8b843f3285e21b04de0eadf92908">m_rhs</a>.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1488</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(unpack_ER(rhs, ctx, ref), ERT::Literal);</div>
<div class="line"><span class="lineno"> 1489</span>    }</div>
<div class="line"><span class="lineno"> 1490</span> </div>
<div class="line"><span class="lineno"> 1491</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> rhs = Interpreter::eval_expr(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#af25c8b843f3285e21b04de0eadf92908">m_rhs</a>.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1492</span>    <span class="keyword">auto</span> rhs_value = unpack_ER(rhs, ctx, ref);</div>
<div class="line"><span class="lineno"> 1493</span>    <span class="comment">// auto result = lhs_value-&gt;binop(expr-&gt;m_op.get(), rhs_value);</span></div>
<div class="line"><span class="lineno"> 1494</span>    std::shared_ptr&lt;earl::value::Obj&gt; result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1495</span>    <span class="keywordflow">switch</span> (expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get()-&gt;type()) {</div>
<div class="line"><span class="lineno"> 1496</span>    <span class="keywordflow">case</span> TokenType::Plus: {</div>
<div class="line"><span class="lineno"> 1497</span>        result = lhs_value-&gt;add(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1498</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1499</span>    <span class="keywordflow">case</span> TokenType::Minus: {</div>
<div class="line"><span class="lineno"> 1500</span>        result = lhs_value-&gt;sub(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1501</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1502</span>    <span class="keywordflow">case</span> TokenType::Asterisk: {</div>
<div class="line"><span class="lineno"> 1503</span>        result = lhs_value-&gt;multiply(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1504</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1505</span>    <span class="keywordflow">case</span> TokenType::Forwardslash: {</div>
<div class="line"><span class="lineno"> 1506</span>        result = lhs_value-&gt;divide(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1507</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1508</span>    <span class="keywordflow">case</span> TokenType::Percent: {</div>
<div class="line"><span class="lineno"> 1509</span>        result = lhs_value-&gt;modulo(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1510</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1511</span>    <span class="keywordflow">case</span> TokenType::Double_Asterisk: {</div>
<div class="line"><span class="lineno"> 1512</span>        result = lhs_value-&gt;power(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1513</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1514</span>    <span class="keywordflow">case</span> TokenType::Greaterthan:</div>
<div class="line"><span class="lineno"> 1515</span>    <span class="keywordflow">case</span> TokenType::Lessthan:</div>
<div class="line"><span class="lineno"> 1516</span>    <span class="keywordflow">case</span> TokenType::Greaterthan_Equals:</div>
<div class="line"><span class="lineno"> 1517</span>    <span class="keywordflow">case</span> TokenType::Lessthan_Equals: {</div>
<div class="line"><span class="lineno"> 1518</span>        result = lhs_value-&gt;gtequality(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1519</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1520</span>    <span class="keywordflow">case</span> TokenType::Double_Equals:</div>
<div class="line"><span class="lineno"> 1521</span>    <span class="keywordflow">case</span> TokenType::Bang_Equals: {</div>
<div class="line"><span class="lineno"> 1522</span>        result = lhs_value-&gt;equality(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1523</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1524</span>    <span class="keywordflow">case</span> TokenType::Backtick_Pipe:</div>
<div class="line"><span class="lineno"> 1525</span>    <span class="keywordflow">case</span> TokenType::Backtick_Caret:</div>
<div class="line"><span class="lineno"> 1526</span>    <span class="keywordflow">case</span> TokenType::Backtick_Ampersand: {</div>
<div class="line"><span class="lineno"> 1527</span>        result = lhs_value-&gt;bitwise(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1528</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1529</span>    <span class="keywordflow">case</span> TokenType::Double_Lessthan:</div>
<div class="line"><span class="lineno"> 1530</span>    <span class="keywordflow">case</span> TokenType::Double_Greaterthan: {</div>
<div class="line"><span class="lineno"> 1531</span>        result = lhs_value-&gt;bitshift(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get(), rhs_value.get());</div>
<div class="line"><span class="lineno"> 1532</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1533</span>    <span class="keywordflow">default</span>: {</div>
<div class="line"><span class="lineno"> 1534</span>        Err::err_wtok(expr-&gt;<a class="code hl_variable" href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">m_op</a>.get());</div>
<div class="line"><span class="lineno"> 1535</span>        <span class="keyword">const</span> std::string msg = <span class="stringliteral">&quot;invalid operator&quot;</span>;</div>
<div class="line"><span class="lineno"> 1536</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1537</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1538</span>    }</div>
<div class="line"><span class="lineno"> 1539</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(result, ERT::Literal);</div>
<div class="line"><span class="lineno"> 1540</span>}</div>
<div class="ttc" id="aclassInterpreterException_html"><div class="ttname"><a href="classInterpreterException.html">InterpreterException</a></div><div class="ttdef"><b>Definition:</b> <a href="err_8hpp_source.html#l00036">err.hpp:36</a></div></div>
<div class="ttc" id="astructExprBinary_html_a09cea010da1219b2f10d0061febe6c41"><div class="ttname"><a href="structExprBinary.html#a09cea010da1219b2f10d0061febe6c41">ExprBinary::m_op</a></div><div class="ttdeci">std::shared_ptr&lt; Token &gt; m_op</div><div class="ttdoc">The token of the binary operator.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00326">ast.hpp:326</a></div></div>
<div class="ttc" id="astructExprBinary_html_addee8cd71ed68a4f7de12a8d32b8a34a"><div class="ttname"><a href="structExprBinary.html#addee8cd71ed68a4f7de12a8d32b8a34a">ExprBinary::m_lhs</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_lhs</div><div class="ttdoc">The expression of the left hand side.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00323">ast.hpp:323</a></div></div>
<div class="ttc" id="astructExprBinary_html_af25c8b843f3285e21b04de0eadf92908"><div class="ttname"><a href="structExprBinary.html#af25c8b843f3285e21b04de0eadf92908">ExprBinary::m_rhs</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_rhs</div><div class="ttdoc">The expression of the right hand side.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00329">ast.hpp:329</a></div></div>
<div class="ttc" id="astructInterpreter_1_1ER_html"><div class="ttname"><a href="structInterpreter_1_1ER.html">Interpreter::ER</a></div><div class="ttdef"><b>Definition:</b> <a href="interpreter_8hpp_source.html#l00053">interpreter.hpp:53</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cbdac6fbb302ccc83bee9af8fa851eb" name="a6cbdac6fbb302ccc83bee9af8fa851eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbdac6fbb302ccc83bee9af8fa851eb">&#9670;&nbsp;</a></span>eval_expr_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInterpreter_1_1ER.html">ER</a> eval_expr_term </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structExprTerm.html">ExprTerm</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01439">1439</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1439</span>                                                                  {</div>
<div class="line"><span class="lineno"> 1440</span>    <span class="keywordflow">switch</span> (expr-&gt;<a class="code hl_function" href="structExprTerm.html#a98c099de07ddbb4c35e9331d043d8c71">get_term_type</a>()) {</div>
<div class="line"><span class="lineno"> 1441</span>    <span class="keywordflow">case</span> ExprTermType::Ident:         <span class="keywordflow">return</span> eval_expr_term_ident(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprIdent.html">ExprIdent</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1442</span>    <span class="keywordflow">case</span> ExprTermType::Int_Literal:   <span class="keywordflow">return</span> eval_expr_term_intlit(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprIntLit.html">ExprIntLit</a> *<span class="keyword">&gt;</span>(expr));</div>
<div class="line"><span class="lineno"> 1443</span>    <span class="keywordflow">case</span> ExprTermType::Str_Literal:   <span class="keywordflow">return</span> eval_expr_term_strlit(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprStrLit.html">ExprStrLit</a> *<span class="keyword">&gt;</span>(expr));</div>
<div class="line"><span class="lineno"> 1444</span>    <span class="keywordflow">case</span> ExprTermType::Char_Literal:  <span class="keywordflow">return</span> eval_expr_term_charlit(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprCharLit.html">ExprCharLit</a> *<span class="keyword">&gt;</span>(expr));</div>
<div class="line"><span class="lineno"> 1445</span>    <span class="keywordflow">case</span> ExprTermType::Float_Literal: <span class="keywordflow">return</span> eval_expr_term_floatlit(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprFloatLit.html">ExprFloatLit</a> *<span class="keyword">&gt;</span>(expr));</div>
<div class="line"><span class="lineno"> 1446</span>    <span class="keywordflow">case</span> ExprTermType::Func_Call:     <span class="keywordflow">return</span> eval_expr_term_funccall(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprFuncCall.html">ExprFuncCall</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1447</span>    <span class="keywordflow">case</span> ExprTermType::List_Literal:  <span class="keywordflow">return</span> eval_expr_term_listlit(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprListLit.html">ExprListLit</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1448</span>    <span class="keywordflow">case</span> ExprTermType::Get:           <span class="keywordflow">return</span> eval_expr_term_get(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprGet.html">ExprGet</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1449</span>    <span class="keywordflow">case</span> ExprTermType::Mod_Access:    <span class="keywordflow">return</span> eval_expr_term_mod_access(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprModAccess.html">ExprModAccess</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1450</span>    <span class="keywordflow">case</span> ExprTermType::Array_Access:  <span class="keywordflow">return</span> eval_expr_term_array_access(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprArrayAccess.html">ExprArrayAccess</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1451</span>    <span class="keywordflow">case</span> ExprTermType::Bool:          <span class="keywordflow">return</span> eval_expr_term_boollit(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprBool.html">ExprBool</a> *<span class="keyword">&gt;</span>(expr));</div>
<div class="line"><span class="lineno"> 1452</span>    <span class="keywordflow">case</span> ExprTermType::None:          <span class="keywordflow">return</span> eval_expr_term_none(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprNone.html">ExprNone</a> *<span class="keyword">&gt;</span>(expr));</div>
<div class="line"><span class="lineno"> 1453</span>    <span class="keywordflow">case</span> ExprTermType::Closure:       <span class="keywordflow">return</span> eval_expr_term_closure(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprClosure.html">ExprClosure</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1454</span>    <span class="keywordflow">case</span> ExprTermType::Range:         <span class="keywordflow">return</span> eval_expr_term_range(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprRange.html">ExprRange</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1455</span>    <span class="keywordflow">case</span> ExprTermType::Tuple:         <span class="keywordflow">return</span> eval_expr_term_tuple(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprTuple.html">ExprTuple</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1456</span>    <span class="keywordflow">case</span> ExprTermType::Slice:         <span class="keywordflow">return</span> eval_expr_term_slice(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprSlice.html">ExprSlice</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1457</span>    <span class="keywordflow">case</span> ExprTermType::Dict:          <span class="keywordflow">return</span> eval_expr_term_dict(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprDict.html">ExprDict</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1458</span>    <span class="keywordflow">case</span> ExprTermType::FStr:          <span class="keywordflow">return</span> eval_expr_term_fstr(<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprFStr.html">ExprFStr</a> *<span class="keyword">&gt;</span>(expr), ctx, ref);</div>
<div class="line"><span class="lineno"> 1459</span>    <span class="keywordflow">default</span>: {</div>
<div class="line"><span class="lineno"> 1460</span>        std::string msg = <span class="stringliteral">&quot;unknown term: `&quot;</span>+std::to_string((<span class="keywordtype">int</span>)expr-&gt;<a class="code hl_function" href="structExprTerm.html#a98c099de07ddbb4c35e9331d043d8c71">get_term_type</a>())+<span class="stringliteral">&quot;`&quot;</span>;</div>
<div class="line"><span class="lineno"> 1461</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1462</span>    }</div>
<div class="line"><span class="lineno"> 1463</span>    }</div>
<div class="line"><span class="lineno"> 1464</span>    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unreachable&quot;</span>);</div>
<div class="line"><span class="lineno"> 1465</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(<span class="keyword">nullptr</span>, ERT::None);</div>
<div class="line"><span class="lineno"> 1466</span>}</div>
<div class="ttc" id="astructExprArrayAccess_html"><div class="ttname"><a href="structExprArrayAccess.html">ExprArrayAccess</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00142">ast.hpp:142</a></div></div>
<div class="ttc" id="astructExprBool_html"><div class="ttname"><a href="structExprBool.html">ExprBool</a></div><div class="ttdoc">The Expression Bool class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00233">ast.hpp:233</a></div></div>
<div class="ttc" id="astructExprCharLit_html"><div class="ttname"><a href="structExprCharLit.html">ExprCharLit</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00224">ast.hpp:224</a></div></div>
<div class="ttc" id="astructExprClosure_html"><div class="ttname"><a href="structExprClosure.html">ExprClosure</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00251">ast.hpp:251</a></div></div>
<div class="ttc" id="astructExprDict_html"><div class="ttname"><a href="structExprDict.html">ExprDict</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00132">ast.hpp:132</a></div></div>
<div class="ttc" id="astructExprFStr_html"><div class="ttname"><a href="structExprFStr.html">ExprFStr</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00216">ast.hpp:216</a></div></div>
<div class="ttc" id="astructExprFloatLit_html"><div class="ttname"><a href="structExprFloatLit.html">ExprFloatLit</a></div><div class="ttdoc">The Expression Float Literal class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00197">ast.hpp:197</a></div></div>
<div class="ttc" id="astructExprFuncCall_html"><div class="ttname"><a href="structExprFuncCall.html">ExprFuncCall</a></div><div class="ttdoc">The Expression Function Call class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00264">ast.hpp:264</a></div></div>
<div class="ttc" id="astructExprGet_html"><div class="ttname"><a href="structExprGet.html">ExprGet</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00162">ast.hpp:162</a></div></div>
<div class="ttc" id="astructExprIdent_html"><div class="ttname"><a href="structExprIdent.html">ExprIdent</a></div><div class="ttdoc">The Expression Identifier class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00153">ast.hpp:153</a></div></div>
<div class="ttc" id="astructExprIntLit_html"><div class="ttname"><a href="structExprIntLit.html">ExprIntLit</a></div><div class="ttdoc">The Expression Integer Literal class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00187">ast.hpp:187</a></div></div>
<div class="ttc" id="astructExprListLit_html"><div class="ttname"><a href="structExprListLit.html">ExprListLit</a></div><div class="ttdoc">The Expression List Literal class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00281">ast.hpp:281</a></div></div>
<div class="ttc" id="astructExprModAccess_html"><div class="ttname"><a href="structExprModAccess.html">ExprModAccess</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00174">ast.hpp:174</a></div></div>
<div class="ttc" id="astructExprNone_html"><div class="ttname"><a href="structExprNone.html">ExprNone</a></div><div class="ttdoc">The Expression None class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00243">ast.hpp:243</a></div></div>
<div class="ttc" id="astructExprRange_html"><div class="ttname"><a href="structExprRange.html">ExprRange</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00291">ast.hpp:291</a></div></div>
<div class="ttc" id="astructExprSlice_html"><div class="ttname"><a href="structExprSlice.html">ExprSlice</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00302">ast.hpp:302</a></div></div>
<div class="ttc" id="astructExprStrLit_html"><div class="ttname"><a href="structExprStrLit.html">ExprStrLit</a></div><div class="ttdoc">The Expression String Literal class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00207">ast.hpp:207</a></div></div>
<div class="ttc" id="astructExprTerm_html_a98c099de07ddbb4c35e9331d043d8c71"><div class="ttname"><a href="structExprTerm.html#a98c099de07ddbb4c35e9331d043d8c71">ExprTerm::get_term_type</a></div><div class="ttdeci">virtual ExprTermType get_term_type() const =0</div><div class="ttdoc">Get the Expression Term type.</div></div>
<div class="ttc" id="astructExprTuple_html"><div class="ttname"><a href="structExprTuple.html">ExprTuple</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00123">ast.hpp:123</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4434dda3007accc915f304f1f1573d84" name="a4434dda3007accc915f304f1f1573d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4434dda3007accc915f304f1f1573d84">&#9670;&nbsp;</a></span>eval_expr_term_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInterpreter_1_1ER.html">ER</a> eval_expr_term_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structExprGet.html">ExprGet</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l00995">995</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  995</span>                                                                     {</div>
<div class="line"><span class="lineno">  996</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> left_er = Interpreter::eval_expr(expr-&gt;m_left.get(), ctx, ref);</div>
<div class="line"><span class="lineno">  997</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> right_er(std::shared_ptr&lt;earl::value::Obj&gt;{}, ERT::None);</div>
<div class="line"><span class="lineno">  998</span> </div>
<div class="line"><span class="lineno">  999</span>    std::visit([&amp;](<span class="keyword">auto</span> &amp;&amp;arg) {</div>
<div class="line"><span class="lineno"> 1000</span>        <span class="keyword">using </span>T = std::decay_t&lt;<span class="keyword">decltype</span>(arg)&gt;;</div>
<div class="line"><span class="lineno"> 1001</span>        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, std::unique_ptr&lt;ExprIdent&gt;&gt;)</div>
<div class="line"><span class="lineno"> 1002</span>            right_er = Interpreter::eval_expr(arg.get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1003</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, std::unique_ptr&lt;ExprFuncCall&gt;&gt;)</div>
<div class="line"><span class="lineno"> 1004</span>            right_er = Interpreter::eval_expr(arg.get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1005</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1006</span>            std::string msg = <span class="stringliteral">&quot;A serious internal error has ocured and has gotten to an unreachable case. Something is very wrong&quot;</span>;</div>
<div class="line"><span class="lineno"> 1007</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1008</span>        }</div>
<div class="line"><span class="lineno"> 1009</span>    }, expr-&gt;m_right);</div>
<div class="line"><span class="lineno"> 1010</span> </div>
<div class="line"><span class="lineno"> 1011</span>    <span class="keywordflow">if</span> (left_er.id == <span class="stringliteral">&quot;this&quot;</span>) {</div>
<div class="line"><span class="lineno"> 1012</span>        <span class="keywordflow">if</span> (ctx-&gt;type() != CtxType::Function &amp;&amp; ctx-&gt;type() != CtxType::Closure) {</div>
<div class="line"><span class="lineno"> 1013</span>            std::string msg = <span class="stringliteral">&quot;Must be in a function in a class context to use the `this` keyword&quot;</span>;</div>
<div class="line"><span class="lineno"> 1014</span>            Err::err_wexpr(expr);</div>
<div class="line"><span class="lineno"> 1015</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1016</span>        }</div>
<div class="line"><span class="lineno"> 1017</span> </div>
<div class="line"><span class="lineno"> 1018</span>        std::shared_ptr&lt;earl::value::Obj&gt; value = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1019</span> </div>
<div class="line"><span class="lineno"> 1020</span>        <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Closure) {</div>
<div class="line"><span class="lineno"> 1021</span>            <span class="keyword">auto</span> closure_ctx = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structClosureCtx.html">ClosureCtx</a> *<span class="keyword">&gt;</span>(ctx.get());</div>
<div class="line"><span class="lineno"> 1022</span>            <span class="keywordflow">if</span> (!closure_ctx-&gt;in_class()) {</div>
<div class="line"><span class="lineno"> 1023</span>                std::string msg = <span class="stringliteral">&quot;Must be in a class context when using the `this` keyword&quot;</span>;</div>
<div class="line"><span class="lineno"> 1024</span>                Err::err_wexpr(expr);</div>
<div class="line"><span class="lineno"> 1025</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1026</span>            }</div>
<div class="line"><span class="lineno"> 1027</span>            <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp(<span class="keyword">nullptr</span>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1028</span>            value = unpack_ER(right_er, closure_ctx-&gt;get_outer_class_owner_ctx(), <span class="comment">/*ref=*/</span><span class="keyword">true</span>, <span class="comment">/*perp=*/</span>&amp;perp);</div>
<div class="line"><span class="lineno"> 1029</span>        }</div>
<div class="line"><span class="lineno"> 1030</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Class) {</div>
<div class="line"><span class="lineno"> 1031</span>            <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp(<span class="keyword">nullptr</span>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1032</span>            value = unpack_ER(right_er, ctx, <span class="comment">/*ref=*/</span><span class="keyword">true</span>, <span class="comment">/*perp=*/</span>&amp;perp);</div>
<div class="line"><span class="lineno"> 1033</span>        }</div>
<div class="line"><span class="lineno"> 1034</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Function) {</div>
<div class="line"><span class="lineno"> 1035</span>            <span class="keyword">auto</span> fctx = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structFunctionCtx.html">FunctionCtx</a> *<span class="keyword">&gt;</span>(ctx.get());</div>
<div class="line"><span class="lineno"> 1036</span> </div>
<div class="line"><span class="lineno"> 1037</span>            <span class="keywordflow">if</span> (!fctx-&gt;in_class()) {</div>
<div class="line"><span class="lineno"> 1038</span>                std::string msg = <span class="stringliteral">&quot;Must be in a class context when using the `this` keyword&quot;</span>;</div>
<div class="line"><span class="lineno"> 1039</span>                Err::err_wexpr(expr);</div>
<div class="line"><span class="lineno"> 1040</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1041</span>            }</div>
<div class="line"><span class="lineno"> 1042</span> </div>
<div class="line"><span class="lineno"> 1043</span>            <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp(<span class="keyword">nullptr</span>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1044</span>            value = unpack_ER(right_er, fctx-&gt;get_outer_class_owner_ctx(), <span class="comment">/*ref=*/</span><span class="keyword">true</span>, <span class="comment">/*perp=*/</span>&amp;perp);</div>
<div class="line"><span class="lineno"> 1045</span>        }</div>
<div class="line"><span class="lineno"> 1046</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1047</span>            std::string msg = <span class="stringliteral">&quot;Must be in a function in a class context to use the `this` keyword&quot;</span>;</div>
<div class="line"><span class="lineno"> 1048</span>            Err::err_wexpr(expr);</div>
<div class="line"><span class="lineno"> 1049</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1050</span>        }</div>
<div class="line"><span class="lineno"> 1051</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(value, ERT::Literal);</div>
<div class="line"><span class="lineno"> 1052</span>    }</div>
<div class="line"><span class="lineno"> 1053</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1054</span>        <span class="keyword">auto</span> left_value = unpack_ER(left_er, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1055</span>        <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp(left_value, <span class="comment">/*this=*/</span><span class="keyword">false</span>, <span class="comment">/*errtok=*/</span>expr-&gt;m_tok.get());</div>
<div class="line"><span class="lineno"> 1056</span>        std::shared_ptr&lt;earl::value::Obj&gt; value = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1057</span> </div>
<div class="line"><span class="lineno"> 1058</span>        <span class="keywordflow">if</span> (left_value-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a9bd81329febf6efe22788e03ddeaf0af">earl::value::Type::Class</a>) {</div>
<div class="line"><span class="lineno"> 1059</span>            <span class="comment">// Class method/member. The right side (right_er) contains the actual call/identifier to be evaluated,</span></div>
<div class="line"><span class="lineno"> 1060</span>            <span class="comment">// and we need the left (left_value)&#39;s context with the preliminary value of (perp).</span></div>
<div class="line"><span class="lineno"> 1061</span>            <span class="comment">// auto cctx = dynamic_cast&lt;earl::value::Class *&gt;(left_value.get())-&gt;ctx();</span></div>
<div class="line"><span class="lineno"> 1062</span>            <span class="comment">// dynamic_cast&lt;ClassCtx *&gt;(cctx.get())-&gt;function_debug_dump();</span></div>
<div class="line"><span class="lineno"> 1063</span>            value = unpack_ER(right_er, <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structearl_1_1value_1_1Class.html">earl::value::Class</a> *<span class="keyword">&gt;</span>(left_value.get())-&gt;ctx(), ref, &amp;perp);</div>
<div class="line"><span class="lineno"> 1064</span>        }</div>
<div class="line"><span class="lineno"> 1065</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1066</span>            <span class="comment">// Function chaining and member intrinsics...</span></div>
<div class="line"><span class="lineno"> 1067</span>            value = unpack_ER(right_er, ctx, ref, &amp;perp);</div>
<div class="line"><span class="lineno"> 1068</span> </div>
<div class="line"><span class="lineno"> 1069</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(value, ERT::Literal);</div>
<div class="line"><span class="lineno"> 1070</span>    }</div>
<div class="line"><span class="lineno"> 1071</span> </div>
<div class="line"><span class="lineno"> 1072</span>    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unreachable&quot;</span>);</div>
<div class="line"><span class="lineno"> 1073</span>}</div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952a9bd81329febf6efe22788e03ddeaf0af"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a9bd81329febf6efe22788e03ddeaf0af">earl::value::Type::Class</a></div><div class="ttdeci">@ Class</div></div>
<div class="ttc" id="astructClosureCtx_html"><div class="ttname"><a href="structClosureCtx.html">ClosureCtx</a></div><div class="ttdef"><b>Definition:</b> <a href="ctx_8hpp_source.html#l00215">ctx.hpp:215</a></div></div>
<div class="ttc" id="astructFunctionCtx_html"><div class="ttname"><a href="structFunctionCtx.html">FunctionCtx</a></div><div class="ttdef"><b>Definition:</b> <a href="ctx_8hpp_source.html#l00135">ctx.hpp:135</a></div></div>
<div class="ttc" id="astructPackedERPreliminary_html"><div class="ttname"><a href="structPackedERPreliminary.html">PackedERPreliminary</a></div><div class="ttdef"><b>Definition:</b> <a href="interpreter_8cpp_source.html#l00048">interpreter.cpp:48</a></div></div>
<div class="ttc" id="astructearl_1_1value_1_1Class_html"><div class="ttname"><a href="structearl_1_1value_1_1Class.html">earl::value::Class</a></div><div class="ttdef"><b>Definition:</b> <a href="earl_8hpp_source.html#l00637">earl.hpp:637</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d8c23ff9e06216e2784ea26cb43276c" name="a7d8c23ff9e06216e2784ea26cb43276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8c23ff9e06216e2784ea26cb43276c">&#9670;&nbsp;</a></span>eval_expr_term_mod_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInterpreter_1_1ER.html">ER</a> eval_expr_term_mod_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structExprModAccess.html">ExprModAccess</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l00873">873</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  873</span>                                                                                  {</div>
<div class="line"><span class="lineno">  874</span>    <a class="code hl_struct" href="structExprModAccess.html">ExprModAccess</a> *mod_access = expr;</div>
<div class="line"><span class="lineno">  875</span>    <a class="code hl_struct" href="structExprIdent.html">ExprIdent</a>     *left_ident = mod_access-&gt;m_expr_ident.get();</div>
<div class="line"><span class="lineno">  876</span>    <span class="keyword">const</span> <span class="keyword">auto</span>    &amp;left_id    = left_ident-&gt;<a class="code hl_variable" href="structExprIdent.html#af356c4cab51f28f4f6021b621d1c5a15">m_tok</a>-&gt;lexeme();</div>
<div class="line"><span class="lineno">  877</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> right_er(std::shared_ptr&lt;earl::value::Obj&gt;{}, ERT::None);</div>
<div class="line"><span class="lineno">  878</span> </div>
<div class="line"><span class="lineno">  879</span>    std::shared_ptr&lt;Ctx&gt; *ctx_ptr = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  880</span> </div>
<div class="line"><span class="lineno">  881</span>    <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::World)</div>
<div class="line"><span class="lineno">  882</span>        ctx_ptr = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;get_import(left_id);</div>
<div class="line"><span class="lineno">  883</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Function) {</div>
<div class="line"><span class="lineno">  884</span>        <span class="keyword">auto</span> world = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structFunctionCtx.html">FunctionCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;get_outer_world_owner();</div>
<div class="line"><span class="lineno">  885</span>        ctx_ptr = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(world.get())-&gt;get_import(left_id);</div>
<div class="line"><span class="lineno">  886</span>    }</div>
<div class="line"><span class="lineno">  887</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Class) {</div>
<div class="line"><span class="lineno">  888</span>        <span class="keyword">auto</span> klass = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structClassCtx.html">ClassCtx</a> *<span class="keyword">&gt;</span>(ctx.get());</div>
<div class="line"><span class="lineno">  889</span>        <span class="keyword">auto</span> world = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(klass-&gt;get_world_owner().get());</div>
<div class="line"><span class="lineno">  890</span>        ctx_ptr = world-&gt;get_import(left_id);</div>
<div class="line"><span class="lineno">  891</span>    }</div>
<div class="line"><span class="lineno">  892</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Closure) {</div>
<div class="line"><span class="lineno">  893</span>        <span class="keyword">auto</span> world = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structClosureCtx.html">ClosureCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;get_outer_world_owner();</div>
<div class="line"><span class="lineno">  894</span>        ctx_ptr = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(world.get())-&gt;get_import(left_id);</div>
<div class="line"><span class="lineno">  895</span>    }</div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span>    std::shared_ptr&lt;Ctx&gt; &amp;other_ctx = *ctx_ptr;</div>
<div class="line"><span class="lineno">  898</span> </div>
<div class="line"><span class="lineno">  899</span>    std::visit([&amp;](<span class="keyword">auto</span> &amp;&amp;arg) {</div>
<div class="line"><span class="lineno">  900</span>        <span class="keyword">using </span>T = std::decay_t&lt;<span class="keyword">decltype</span>(arg)&gt;;</div>
<div class="line"><span class="lineno">  901</span>        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, std::unique_ptr&lt;ExprIdent&gt;&gt;)</div>
<div class="line"><span class="lineno">  902</span>            right_er = Interpreter::eval_expr(arg.get(), other_ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  903</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, std::unique_ptr&lt;ExprFuncCall&gt;&gt;)</div>
<div class="line"><span class="lineno">  904</span>            right_er = Interpreter::eval_expr(arg.get(), other_ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  905</span>        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  906</span>            std::string msg = <span class="stringliteral">&quot;A serious internal error has ocured and has gotten to an unreachable case. Something is very wrong&quot;</span>;</div>
<div class="line"><span class="lineno">  907</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  908</span>        }</div>
<div class="line"><span class="lineno">  909</span>    }, expr-&gt;m_right);</div>
<div class="line"><span class="lineno">  910</span> </div>
<div class="line"><span class="lineno">  911</span>    <span class="keywordflow">if</span> (right_er.is_class_instant()) {</div>
<div class="line"><span class="lineno">  912</span>        assert(right_er.ctx-&gt;type() == CtxType::World);</div>
<div class="line"><span class="lineno">  913</span>        <a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *world = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(right_er.ctx.get());</div>
<div class="line"><span class="lineno">  914</span>        <span class="keywordflow">if</span> (world-&gt;class_is_defined(right_er.id)) {</div>
<div class="line"><span class="lineno">  915</span>            <span class="keywordflow">if</span> ((world-&gt;class_get(right_er.id)-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Pub)) == 0) {</div>
<div class="line"><span class="lineno">  916</span>                Err::err_wexpr(expr);</div>
<div class="line"><span class="lineno">  917</span>                std::string msg = <span class="stringliteral">&quot;class `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  918</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  919</span>            }</div>
<div class="line"><span class="lineno">  920</span>        }</div>
<div class="line"><span class="lineno">  921</span>        <span class="keyword">auto</span> params = evaluate_function_parameters(<span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structExprFuncCall.html">ExprFuncCall</a> *<span class="keyword">&gt;</span>(right_er.extra), ctx, ref);</div>
<div class="line"><span class="lineno">  922</span>        <span class="keyword">auto</span> class_instantiation = eval_class_instantiation(<span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structExprFuncCall.html">ExprFuncCall</a> *<span class="keyword">&gt;</span>(right_er.extra), right_er.id, params, right_er.ctx, ref);</div>
<div class="line"><span class="lineno">  923</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(class_instantiation, ERT::Literal, <span class="comment">/*id=*/</span><span class="stringliteral">&quot;&quot;</span>, <span class="comment">/*extra=*/</span><span class="keyword">nullptr</span>, <span class="comment">/*ctx=*/</span>ctx);</div>
<div class="line"><span class="lineno">  924</span>    }</div>
<div class="line"><span class="lineno">  925</span>    <span class="keywordflow">if</span> (right_er.is_function_ident()) {</div>
<div class="line"><span class="lineno">  926</span>        <span class="comment">// Check if the function has @pub attribute</span></div>
<div class="line"><span class="lineno">  927</span>        <span class="keywordflow">if</span> (right_er.ctx-&gt;function_exists(right_er.id)) {</div>
<div class="line"><span class="lineno">  928</span>            <span class="keywordflow">if</span> (!right_er.ctx-&gt;function_get(right_er.id)-&gt;is_pub()) {</div>
<div class="line"><span class="lineno">  929</span>                std::string msg = <span class="stringliteral">&quot;function `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  930</span>                Err::err_wexpr(left_ident);</div>
<div class="line"><span class="lineno">  931</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  932</span>            }</div>
<div class="line"><span class="lineno">  933</span>        }</div>
<div class="line"><span class="lineno">  934</span>        <span class="comment">// Check if the closure has @pub attribute</span></div>
<div class="line"><span class="lineno">  935</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (right_er.ctx-&gt;closure_exists(right_er.id)) {</div>
<div class="line"><span class="lineno">  936</span>            <span class="keywordflow">if</span> (!right_er.ctx-&gt;function_get(right_er.id)-&gt;is_pub()) {</div>
<div class="line"><span class="lineno">  937</span>                std::string msg = <span class="stringliteral">&quot;variable `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  938</span>                Err::err_wexpr(left_ident);</div>
<div class="line"><span class="lineno">  939</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  940</span>            }</div>
<div class="line"><span class="lineno">  941</span>        }</div>
<div class="line"><span class="lineno">  942</span>        <span class="keyword">auto</span> func = eval_user_defined_function_wo_params(right_er.id, <span class="keyword">static_cast&lt;</span><a class="code hl_struct" href="structExprFuncCall.html">ExprFuncCall</a> *<span class="keyword">&gt;</span>(right_er.extra), ctx, right_er.ctx);</div>
<div class="line"><span class="lineno">  943</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(func, ERT::Literal);</div>
<div class="line"><span class="lineno">  944</span>    }</div>
<div class="line"><span class="lineno">  945</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (right_er.is_ident()) {</div>
<div class="line"><span class="lineno">  946</span>        <span class="keyword">auto</span> value = unpack_ER(right_er, other_ctx, ref);</div>
<div class="line"><span class="lineno">  947</span>        <span class="comment">// Check if it is a variable</span></div>
<div class="line"><span class="lineno">  948</span>        <span class="keywordflow">if</span> (right_er.ctx-&gt;variable_exists(right_er.id)) {</div>
<div class="line"><span class="lineno">  949</span>            <span class="keywordflow">if</span> (!right_er.ctx-&gt;variable_get(right_er.id)-&gt;is_pub()) {</div>
<div class="line"><span class="lineno">  950</span>                std::string msg = <span class="stringliteral">&quot;variable `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  951</span>                Err::err_wexpr(left_ident);</div>
<div class="line"><span class="lineno">  952</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  953</span>            }</div>
<div class="line"><span class="lineno">  954</span>            <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(value, ERT::Literal);</div>
<div class="line"><span class="lineno">  955</span>        }</div>
<div class="line"><span class="lineno">  956</span>        <span class="comment">// Check if it is a function identifier</span></div>
<div class="line"><span class="lineno">  957</span>        <span class="keywordflow">if</span> (right_er.ctx-&gt;function_exists(right_er.id)) {</div>
<div class="line"><span class="lineno">  958</span>            <span class="keywordflow">if</span> (!right_er.ctx-&gt;function_get(right_er.id)-&gt;is_pub()) {</div>
<div class="line"><span class="lineno">  959</span>                std::string msg = <span class="stringliteral">&quot;function `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  960</span>                Err::err_wexpr(left_ident);</div>
<div class="line"><span class="lineno">  961</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  962</span>            }</div>
<div class="line"><span class="lineno">  963</span>            <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(value, ERT::Literal);</div>
<div class="line"><span class="lineno">  964</span>        }</div>
<div class="line"><span class="lineno">  965</span> </div>
<div class="line"><span class="lineno">  966</span>        <span class="keywordflow">if</span> (right_er.ctx-&gt;type() == CtxType::World) {</div>
<div class="line"><span class="lineno">  967</span>            <span class="keyword">auto</span> worldctx = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(right_er.ctx.get());</div>
<div class="line"><span class="lineno">  968</span>            <span class="keywordflow">if</span> (worldctx-&gt;class_is_defined(right_er.id)) {</div>
<div class="line"><span class="lineno">  969</span>                <span class="keyword">auto</span> class_stmt = worldctx-&gt;class_get(right_er.id);</div>
<div class="line"><span class="lineno">  970</span>                <span class="keywordflow">if</span> ((class_stmt-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Pub)) == 0) {</div>
<div class="line"><span class="lineno">  971</span>                    std::string msg = <span class="stringliteral">&quot;class `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  972</span>                    Err::err_wexpr(left_ident);</div>
<div class="line"><span class="lineno">  973</span>                    <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  974</span>                }</div>
<div class="line"><span class="lineno">  975</span>                <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(value, ERT::Literal);</div>
<div class="line"><span class="lineno">  976</span>            }</div>
<div class="line"><span class="lineno">  977</span>        }</div>
<div class="line"><span class="lineno">  978</span> </div>
<div class="line"><span class="lineno">  979</span>        <span class="comment">// Check if it is a class identifier</span></div>
<div class="line"><span class="lineno">  980</span> </div>
<div class="line"><span class="lineno">  981</span>        <span class="comment">// It must be an enum</span></div>
<div class="line"><span class="lineno">  982</span>        assert(value-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952acf20423ed48998082c20099488a0917c">earl::value::Type::Enum</a>);</div>
<div class="line"><span class="lineno">  983</span>        <span class="keywordflow">if</span> (!<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structearl_1_1value_1_1Enum.html">earl::value::Enum</a> *<span class="keyword">&gt;</span>(value.get())-&gt;is_pub()) {</div>
<div class="line"><span class="lineno">  984</span>            std::string msg = <span class="stringliteral">&quot;enumeration `&quot;</span>+right_er.id+<span class="stringliteral">&quot;` in module `&quot;</span>+left_id+<span class="stringliteral">&quot;` does not contain the @pub attribute&quot;</span>;</div>
<div class="line"><span class="lineno">  985</span>            Err::err_wexpr(left_ident);</div>
<div class="line"><span class="lineno">  986</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno">  987</span>        }</div>
<div class="line"><span class="lineno">  988</span>        <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(value, ERT::Literal);</div>
<div class="line"><span class="lineno">  989</span>    }</div>
<div class="line"><span class="lineno">  990</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  991</span>        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;unimplemented&quot;</span>);</div>
<div class="line"><span class="lineno">  992</span>}</div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952acf20423ed48998082c20099488a0917c"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952acf20423ed48998082c20099488a0917c">earl::value::Type::Enum</a></div><div class="ttdeci">@ Enum</div></div>
<div class="ttc" id="astructClassCtx_html"><div class="ttname"><a href="structClassCtx.html">ClassCtx</a></div><div class="ttdef"><b>Definition:</b> <a href="ctx_8hpp_source.html#l00172">ctx.hpp:172</a></div></div>
<div class="ttc" id="astructExprIdent_html_af356c4cab51f28f4f6021b621d1c5a15"><div class="ttname"><a href="structExprIdent.html#af356c4cab51f28f4f6021b621d1c5a15">ExprIdent::m_tok</a></div><div class="ttdeci">std::shared_ptr&lt; Token &gt; m_tok</div><div class="ttdoc">The token of the identifier.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00155">ast.hpp:155</a></div></div>
<div class="ttc" id="astructWorldCtx_html"><div class="ttname"><a href="structWorldCtx.html">WorldCtx</a></div><div class="ttdef"><b>Definition:</b> <a href="ctx_8hpp_source.html#l00073">ctx.hpp:73</a></div></div>
<div class="ttc" id="astructearl_1_1value_1_1Enum_html"><div class="ttname"><a href="structearl_1_1value_1_1Enum.html">earl::value::Enum</a></div><div class="ttdef"><b>Definition:</b> <a href="earl_8hpp_source.html#l00696">earl.hpp:696</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6bdefe66e021e5f78f55d17a893aeb7a" name="a6bdefe66e021e5f78f55d17a893aeb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdefe66e021e5f78f55d17a893aeb7a">&#9670;&nbsp;</a></span>eval_expr_unary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInterpreter_1_1ER.html">ER</a> eval_expr_unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structExprUnary.html">ExprUnary</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01543">1543</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1543</span>                                                                    {</div>
<div class="line"><span class="lineno"> 1544</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> rhs = Interpreter::eval_expr(expr-&gt;m_expr.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1545</span>    <span class="keyword">auto</span> expr_value = unpack_ER(rhs, ctx, ref);</div>
<div class="line"><span class="lineno"> 1546</span>    <span class="keyword">auto</span> result = expr_value-&gt;unaryop(expr-&gt;m_op.get());</div>
<div class="line"><span class="lineno"> 1547</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a>(result, ERT::Literal);</div>
<div class="line"><span class="lineno"> 1548</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a73292a1e2fa4be29c99882080f90287c" name="a73292a1e2fa4be29c99882080f90287c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73292a1e2fa4be29c99882080f90287c">&#9670;&nbsp;</a></span>eval_stmt_break()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_break </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtBreak.html">StmtBreak</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01892">1892</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1892</span>                                                          {</div>
<div class="line"><span class="lineno"> 1893</span>    (void)stmt;</div>
<div class="line"><span class="lineno"> 1894</span>    (void)ctx;</div>
<div class="line"><span class="lineno"> 1895</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1896</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Break&gt;();</div>
<div class="line"><span class="lineno"> 1897</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ab562db9e7f7a90900f8bb9da700970" name="a3ab562db9e7f7a90900f8bb9da700970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab562db9e7f7a90900f8bb9da700970">&#9670;&nbsp;</a></span>eval_stmt_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtClass.html">StmtClass</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l02231">2231</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2231</span>                                                          {</div>
<div class="line"><span class="lineno"> 2232</span>    <span class="keywordflow">if</span> ((flags &amp; __VERBOSE) != 0)</div>
<div class="line"><span class="lineno"> 2233</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;[EARL] defining class &quot;</span> &lt;&lt; stmt-&gt;m_id-&gt;lexeme() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 2234</span>    <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;define_class(stmt);</div>
<div class="line"><span class="lineno"> 2235</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2236</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 2237</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d92337c12e776348ff89e45479736ab" name="a3d92337c12e776348ff89e45479736ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d92337c12e776348ff89e45479736ab">&#9670;&nbsp;</a></span>eval_stmt_def()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_def </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtDef.html">StmtDef</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01834">1834</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1834</span>                                                      {</div>
<div class="line"><span class="lineno"> 1835</span>    <span class="keywordflow">if</span> ((flags &amp; __VERBOSE) != 0)</div>
<div class="line"><span class="lineno"> 1836</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;[EARL] defining function &quot;</span> &lt;&lt; stmt-&gt;<a class="code hl_variable" href="structStmtDef.html#ae21b86e7ea579a20c2be80ae6a5162ae">m_id</a>-&gt;lexeme() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1837</span> </div>
<div class="line"><span class="lineno"> 1838</span>    <span class="keyword">const</span> std::string &amp;<span class="keywordtype">id</span> = stmt-&gt;<a class="code hl_variable" href="structStmtDef.html#ae21b86e7ea579a20c2be80ae6a5162ae">m_id</a>-&gt;lexeme();</div>
<div class="line"><span class="lineno"> 1839</span>    <span class="keywordflow">if</span> (ctx-&gt;function_exists(<span class="keywordtype">id</span>)) {</div>
<div class="line"><span class="lineno"> 1840</span>        std::string msg = <span class="stringliteral">&quot;function `&quot;</span>+<span class="keywordtype">id</span>+<span class="stringliteral">&quot;` has already been declared&quot;</span>;</div>
<div class="line"><span class="lineno"> 1841</span>        <span class="keyword">auto</span> conflict = ctx-&gt;function_get(<span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno"> 1842</span>        Err::err_wconflict(stmt-&gt;<a class="code hl_variable" href="structStmtDef.html#ae21b86e7ea579a20c2be80ae6a5162ae">m_id</a>.get(), conflict-&gt;gettok());</div>
<div class="line"><span class="lineno"> 1843</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1844</span>    }</div>
<div class="line"><span class="lineno"> 1845</span> </div>
<div class="line"><span class="lineno"> 1846</span>    std::vector&lt;std::pair&lt;std::pair&lt;Token *, __Type *&gt;, uint32_t&gt;&gt; args;</div>
<div class="line"><span class="lineno"> 1847</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;entry : stmt-&gt;m_args) {</div>
<div class="line"><span class="lineno"> 1848</span>        <a class="code hl_struct" href="struct____Type.html">__Type</a> *ty = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1849</span>        <span class="keywordflow">if</span> (entry.first.second.has_value()) {</div>
<div class="line"><span class="lineno"> 1850</span>            ty = entry.first.second.value().get();</div>
<div class="line"><span class="lineno"> 1851</span>        }</div>
<div class="line"><span class="lineno"> 1852</span>        args.push_back(std::make_pair(std::make_pair(entry.first.first.get(), ty), entry.second));</div>
<div class="line"><span class="lineno"> 1853</span>    }</div>
<div class="line"><span class="lineno"> 1854</span> </div>
<div class="line"><span class="lineno"> 1855</span>    std::optional&lt;__Type *&gt; explicit_type = {};</div>
<div class="line"><span class="lineno"> 1856</span>    <span class="keywordflow">if</span> (stmt-&gt;m_ty.has_value())</div>
<div class="line"><span class="lineno"> 1857</span>        explicit_type = stmt-&gt;m_ty.value().get();</div>
<div class="line"><span class="lineno"> 1858</span> </div>
<div class="line"><span class="lineno"> 1859</span>    <span class="keyword">auto</span> func = std::make_shared&lt;earl::function::Obj&gt;(stmt, args, stmt-&gt;<a class="code hl_variable" href="structStmtDef.html#ae21b86e7ea579a20c2be80ae6a5162ae">m_id</a>.get(), explicit_type, std::move(stmt-&gt;m_info));</div>
<div class="line"><span class="lineno"> 1860</span>    ctx-&gt;function_add(func);</div>
<div class="line"><span class="lineno"> 1861</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1862</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1863</span>}</div>
<div class="ttc" id="astructStmtDef_html_ae21b86e7ea579a20c2be80ae6a5162ae"><div class="ttname"><a href="structStmtDef.html#ae21b86e7ea579a20c2be80ae6a5162ae">StmtDef::m_id</a></div><div class="ttdeci">std::shared_ptr&lt; Token &gt; m_id</div><div class="ttdoc">The token of the function name.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00362">ast.hpp:362</a></div></div>
<div class="ttc" id="astruct____Type_html"><div class="ttname"><a href="struct____Type.html">__Type</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00098">ast.hpp:98</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb8fe0301baaa20a2e89b4164228c88b" name="abb8fe0301baaa20a2e89b4164228c88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8fe0301baaa20a2e89b4164228c88b">&#9670;&nbsp;</a></span>eval_stmt_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtExpr.html">StmtExpr</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01796">1796</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1796</span>                                                        {</div>
<div class="line"><span class="lineno"> 1797</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtExpr.html#a12615a9350bf105bc5371a7f99bcfebf">m_expr</a>.get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1798</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1799</span>    <span class="keyword">auto</span> value = unpack_ER(er, ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1800</span>    <span class="keywordflow">if</span> (value &amp;&amp; value-&gt;type() != <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d">earl::value::Type::Void</a> &amp;&amp; ctx-&gt;type() != CtxType::World) {</div>
<div class="line"><span class="lineno"> 1801</span>        Err::err_wexpr(stmt-&gt;<a class="code hl_variable" href="structStmtExpr.html#a12615a9350bf105bc5371a7f99bcfebf">m_expr</a>.get());</div>
<div class="line"><span class="lineno"> 1802</span>        Err::warn(<span class="stringliteral">&quot;Inplace expression will be evaluated and returned. Either explicitly `return` or assign the unused value to a unit binding: `let _ = &lt;expr&gt;;`&quot;</span>);</div>
<div class="line"><span class="lineno"> 1803</span>    }</div>
<div class="line"><span class="lineno"> 1804</span>    <span class="keywordflow">return</span> value;</div>
<div class="line"><span class="lineno"> 1805</span>}</div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d">earl::value::Type::Void</a></div><div class="ttdeci">@ Void</div></div>
<div class="ttc" id="astructStmtExpr_html_a12615a9350bf105bc5371a7f99bcfebf"><div class="ttname"><a href="structStmtExpr.html#a12615a9350bf105bc5371a7f99bcfebf">StmtExpr::m_expr</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_expr</div><div class="ttdoc">The expression to be evaluated.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00447">ast.hpp:447</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9354fc46ec4c0a84eac595508cc952ed" name="a9354fc46ec4c0a84eac595508cc952ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9354fc46ec4c0a84eac595508cc952ed">&#9670;&nbsp;</a></span>eval_stmt_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtFor.html">StmtFor</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l02166">2166</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2166</span>                                                      {</div>
<div class="line"><span class="lineno"> 2167</span>    std::shared_ptr&lt;earl::value::Obj&gt; result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2168</span> </div>
<div class="line"><span class="lineno"> 2169</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> start_er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtFor.html#a58b471e4065f3ac18f19a33cbaa399a5">m_start</a>.get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 2170</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> end_er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtFor.html#abbe5ebf981bda62db8fa8705eb249ad3">m_end</a>.get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 2171</span> </div>
<div class="line"><span class="lineno"> 2172</span>    <span class="keyword">auto</span> start_expr = unpack_ER(start_er, ctx, <span class="keyword">false</span>); <span class="comment">// DO NOT MAKE THIS TRUE! BREAKS LOOPS ENTIRELY</span></div>
<div class="line"><span class="lineno"> 2173</span>    <span class="keyword">auto</span> end_expr = unpack_ER(end_er, ctx, <span class="keyword">true</span>); <span class="comment">// POSSIBLE BREAK, WAS FALSE</span></div>
<div class="line"><span class="lineno"> 2174</span> </div>
<div class="line"><span class="lineno"> 2175</span>    <span class="keyword">auto</span> enumerator = std::make_shared&lt;earl::variable::Obj&gt;(stmt-&gt;<a class="code hl_variable" href="structStmtFor.html#a95e9475ee86f7028595b84f1ba6bc6f3">m_enumerator</a>.get(), start_expr);</div>
<div class="line"><span class="lineno"> 2176</span> </div>
<div class="line"><span class="lineno"> 2177</span>    <span class="keywordflow">if</span> (ctx-&gt;variable_exists(enumerator-&gt;id())) {</div>
<div class="line"><span class="lineno"> 2178</span>        std::string msg = <span class="stringliteral">&quot;variable `&quot;</span>+stmt-&gt;<a class="code hl_variable" href="structStmtFor.html#a95e9475ee86f7028595b84f1ba6bc6f3">m_enumerator</a>-&gt;lexeme()+<span class="stringliteral">&quot;` is already declared&quot;</span>;</div>
<div class="line"><span class="lineno"> 2179</span>        <span class="keyword">auto</span> conflict = ctx-&gt;variable_get(enumerator-&gt;id());</div>
<div class="line"><span class="lineno"> 2180</span>        Err::err_wconflict(stmt-&gt;<a class="code hl_variable" href="structStmtFor.html#a95e9475ee86f7028595b84f1ba6bc6f3">m_enumerator</a>.get(), conflict-&gt;gettok());</div>
<div class="line"><span class="lineno"> 2181</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 2182</span>    }</div>
<div class="line"><span class="lineno"> 2183</span>    ctx-&gt;variable_add(enumerator);</div>
<div class="line"><span class="lineno"> 2184</span> </div>
<div class="line"><span class="lineno"> 2185</span>    <a class="code hl_struct" href="structearl_1_1value_1_1Int.html">earl::value::Int</a> *start = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structearl_1_1value_1_1Int.html">earl::value::Int</a> *<span class="keyword">&gt;</span>(start_expr.get());</div>
<div class="line"><span class="lineno"> 2186</span>    <a class="code hl_struct" href="structearl_1_1value_1_1Int.html">earl::value::Int</a> *end = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structearl_1_1value_1_1Int.html">earl::value::Int</a> *<span class="keyword">&gt;</span>(end_expr.get());</div>
<div class="line"><span class="lineno"> 2187</span> </div>
<div class="line"><span class="lineno"> 2188</span>    <span class="keywordtype">bool</span> lt = start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>() &lt;= end-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>();</div>
<div class="line"><span class="lineno"> 2189</span>    <span class="keywordtype">bool</span> gt = start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>() &gt; end-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>();</div>
<div class="line"><span class="lineno"> 2190</span> </div>
<div class="line"><span class="lineno"> 2191</span>    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><span class="lineno"> 2192</span>        <span class="keywordflow">if</span> (lt &amp;&amp; start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>() &gt; end-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>()-1)</div>
<div class="line"><span class="lineno"> 2193</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2194</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gt &amp;&amp; start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>() &lt; end-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>())</div>
<div class="line"><span class="lineno"> 2195</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2196</span> </div>
<div class="line"><span class="lineno"> 2197</span>        result = Interpreter::eval_stmt_block(stmt-&gt;<a class="code hl_variable" href="structStmtFor.html#a8dcee79c9cb5796891acbc08998e9801">m_block</a>.get(), ctx);</div>
<div class="line"><span class="lineno"> 2198</span> </div>
<div class="line"><span class="lineno"> 2199</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a>) {</div>
<div class="line"><span class="lineno"> 2200</span>            result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2201</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2202</span>        }</div>
<div class="line"><span class="lineno"> 2203</span> </div>
<div class="line"><span class="lineno"> 2204</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a>) {</div>
<div class="line"><span class="lineno"> 2205</span>            <span class="keywordflow">if</span> (lt)</div>
<div class="line"><span class="lineno"> 2206</span>                start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#a2a8e2c6c3485848ede02607402f48ed6">mutate</a>(std::make_shared&lt;earl::value::Int&gt;(start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>()+1).get(), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 2207</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gt)</div>
<div class="line"><span class="lineno"> 2208</span>                start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#a2a8e2c6c3485848ede02607402f48ed6">mutate</a>(std::make_shared&lt;earl::value::Int&gt;(start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>()-1).get(), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 2209</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2210</span>        }</div>
<div class="line"><span class="lineno"> 2211</span> </div>
<div class="line"><span class="lineno"> 2212</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() != <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d">earl::value::Type::Void</a>)</div>
<div class="line"><span class="lineno"> 2213</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2214</span> </div>
<div class="line"><span class="lineno"> 2215</span>        <span class="keywordflow">if</span> (lt)</div>
<div class="line"><span class="lineno"> 2216</span>            start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#a2a8e2c6c3485848ede02607402f48ed6">mutate</a>(std::make_shared&lt;earl::value::Int&gt;(start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>()+1).get(), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 2217</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gt)</div>
<div class="line"><span class="lineno"> 2218</span>            start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#a2a8e2c6c3485848ede02607402f48ed6">mutate</a>(std::make_shared&lt;earl::value::Int&gt;(start-&gt;<a class="code hl_function" href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">value</a>()-1).get(), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 2219</span>    }</div>
<div class="line"><span class="lineno"> 2220</span> </div>
<div class="line"><span class="lineno"> 2221</span>    ctx-&gt;variable_remove(enumerator-&gt;id());</div>
<div class="line"><span class="lineno"> 2222</span> </div>
<div class="line"><span class="lineno"> 2223</span>    <span class="keywordflow">if</span> (result &amp;&amp; (result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a> || result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a>))</div>
<div class="line"><span class="lineno"> 2224</span>        result = std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 2225</span> </div>
<div class="line"><span class="lineno"> 2226</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2227</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno"> 2228</span>}</div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a></div><div class="ttdeci">@ Continue</div></div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a></div><div class="ttdeci">@ Break</div></div>
<div class="ttc" id="astructStmtFor_html_a58b471e4065f3ac18f19a33cbaa399a5"><div class="ttname"><a href="structStmtFor.html#a58b471e4065f3ac18f19a33cbaa399a5">StmtFor::m_start</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_start</div><div class="ttdoc">The starting expression.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00540">ast.hpp:540</a></div></div>
<div class="ttc" id="astructStmtFor_html_a8dcee79c9cb5796891acbc08998e9801"><div class="ttname"><a href="structStmtFor.html#a8dcee79c9cb5796891acbc08998e9801">StmtFor::m_block</a></div><div class="ttdeci">std::unique_ptr&lt; StmtBlock &gt; m_block</div><div class="ttdoc">The block for the loop to execute.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00546">ast.hpp:546</a></div></div>
<div class="ttc" id="astructStmtFor_html_a95e9475ee86f7028595b84f1ba6bc6f3"><div class="ttname"><a href="structStmtFor.html#a95e9475ee86f7028595b84f1ba6bc6f3">StmtFor::m_enumerator</a></div><div class="ttdeci">std::shared_ptr&lt; Token &gt; m_enumerator</div><div class="ttdoc">The identifier of the enumerator variable.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00537">ast.hpp:537</a></div></div>
<div class="ttc" id="astructStmtFor_html_abbe5ebf981bda62db8fa8705eb249ad3"><div class="ttname"><a href="structStmtFor.html#abbe5ebf981bda62db8fa8705eb249ad3">StmtFor::m_end</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_end</div><div class="ttdoc">The ending expression.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00543">ast.hpp:543</a></div></div>
<div class="ttc" id="astructearl_1_1value_1_1Int_html"><div class="ttname"><a href="structearl_1_1value_1_1Int.html">earl::value::Int</a></div><div class="ttdoc">The structure that represents EARL 32bit integers.</div><div class="ttdef"><b>Definition:</b> <a href="earl_8hpp_source.html#l00299">earl.hpp:299</a></div></div>
<div class="ttc" id="astructearl_1_1value_1_1Int_html_a2a8e2c6c3485848ede02607402f48ed6"><div class="ttname"><a href="structearl_1_1value_1_1Int.html#a2a8e2c6c3485848ede02607402f48ed6">earl::value::Int::mutate</a></div><div class="ttdeci">void mutate(Obj *other, StmtMut *stmt) override</div><div class="ttdoc">Modify the underlying data of THIS value with the underlying value of another object.</div><div class="ttdef"><b>Definition:</b> <a href="int_8cpp_source.html#l00193">int.cpp:193</a></div></div>
<div class="ttc" id="astructearl_1_1value_1_1Int_html_ac6b683e84d4a4a9119a9fff75f2784b4"><div class="ttname"><a href="structearl_1_1value_1_1Int.html#ac6b683e84d4a4a9119a9fff75f2784b4">earl::value::Int::value</a></div><div class="ttdeci">int value(void)</div><div class="ttdoc">Get the underlying integer value.</div><div class="ttdef"><b>Definition:</b> <a href="int_8cpp_source.html#l00039">int.cpp:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aee321cdf1b8fb41e2d8ab35fd9475d3c" name="aee321cdf1b8fb41e2d8ab35fd9475d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee321cdf1b8fb41e2d8ab35fd9475d3c">&#9670;&nbsp;</a></span>eval_stmt_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtForeach.html">StmtForeach</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l02058">2058</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2058</span>                                                              {</div>
<div class="line"><span class="lineno"> 2059</span>    <span class="keywordtype">bool</span> ref = (stmt-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Ref)) != 0;</div>
<div class="line"><span class="lineno"> 2060</span> </div>
<div class="line"><span class="lineno"> 2061</span>    std::shared_ptr&lt;earl::value::Obj&gt; result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2062</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> expr_er = Interpreter::eval_expr(stmt-&gt;m_expr.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 2063</span>    <span class="keyword">auto</span> expr = unpack_ER(expr_er, ctx, ref);</div>
<div class="line"><span class="lineno"> 2064</span> </div>
<div class="line"><span class="lineno"> 2065</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;enumer : stmt-&gt;<a class="code hl_variable" href="structStmtForeach.html#a130042e5e76a23ac76696a5f29604df0">m_enumerators</a>) {</div>
<div class="line"><span class="lineno"> 2066</span>        <span class="keyword">const</span> std::string &amp;<span class="keywordtype">id</span> = enumer-&gt;lexeme();</div>
<div class="line"><span class="lineno"> 2067</span>        <span class="keywordflow">if</span> (ctx-&gt;variable_exists(<span class="keywordtype">id</span>)) {</div>
<div class="line"><span class="lineno"> 2068</span>            std::string msg = <span class="stringliteral">&quot;variable `&quot;</span>+<span class="keywordtype">id</span>+<span class="stringliteral">&quot;` is already declared&quot;</span>;</div>
<div class="line"><span class="lineno"> 2069</span>            <span class="keyword">auto</span> conflict = ctx-&gt;variable_get(<span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno"> 2070</span>            Err::err_wconflict(enumer.get(), conflict-&gt;gettok());</div>
<div class="line"><span class="lineno"> 2071</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 2072</span>        }</div>
<div class="line"><span class="lineno"> 2073</span>    }</div>
<div class="line"><span class="lineno"> 2074</span> </div>
<div class="line"><span class="lineno"> 2075</span>    std::vector&lt;std::shared_ptr&lt;earl::variable::Obj&gt;&gt; enumerators(stmt-&gt;<a class="code hl_variable" href="structStmtForeach.html#a130042e5e76a23ac76696a5f29604df0">m_enumerators</a>.size(), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 2076</span>    <span class="keyword">auto</span> wrapped_iterator = expr-&gt;iter_begin(), wrapped_iterator_end = expr-&gt;iter_end();</div>
<div class="line"><span class="lineno"> 2077</span> </div>
<div class="line"><span class="lineno"> 2078</span>    <span class="comment">// Will reduce the type of the current iterator and will</span></div>
<div class="line"><span class="lineno"> 2079</span>    <span class="comment">// call handle_enumerators() on the enumerators of the foreach loop.</span></div>
<div class="line"><span class="lineno"> 2080</span>    <span class="keyword">auto</span> iterator_reduce = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it, <span class="keyword">auto</span> handle_enumerators) {</div>
<div class="line"><span class="lineno"> 2081</span>        std::visit([&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it){</div>
<div class="line"><span class="lineno"> 2082</span>            <span class="keyword">using </span>T = std::decay_t&lt;<span class="keyword">decltype</span>(it)&gt;;</div>
<div class="line"><span class="lineno"> 2083</span> </div>
<div class="line"><span class="lineno"> 2084</span>            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, earl::value::ListIterator&gt; ||</div>
<div class="line"><span class="lineno"> 2085</span>                          std::is_same_v&lt;T, earl::value::StrIterator&gt;) {</div>
<div class="line"><span class="lineno"> 2086</span>                handle_enumerators(*it);</div>
<div class="line"><span class="lineno"> 2087</span>            }</div>
<div class="line"><span class="lineno"> 2088</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2089</span>                <span class="keyword">static_assert</span>(std::is_same_v&lt;T, earl::value::DictIntIterator&gt; ||</div>
<div class="line"><span class="lineno"> 2090</span>                              std::is_same_v&lt;T, earl::value::DictCharIterator&gt; ||</div>
<div class="line"><span class="lineno"> 2091</span>                              std::is_same_v&lt;T, earl::value::DictFloatIterator&gt; ||</div>
<div class="line"><span class="lineno"> 2092</span>                              std::is_same_v&lt;T, earl::value::DictStrIterator&gt;);</div>
<div class="line"><span class="lineno"> 2093</span>                std::vector&lt;std::shared_ptr&lt;earl::value::Obj&gt;&gt; elements = {};</div>
<div class="line"><span class="lineno"> 2094</span>                <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, earl::value::DictIntIterator&gt;)</div>
<div class="line"><span class="lineno"> 2095</span>                    elements.push_back(std::make_shared&lt;earl::value::Int&gt;(it-&gt;first));</div>
<div class="line"><span class="lineno"> 2096</span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, earl::value::DictCharIterator&gt;)</div>
<div class="line"><span class="lineno"> 2097</span>                    elements.push_back(std::make_shared&lt;earl::value::Char&gt;(it-&gt;first));</div>
<div class="line"><span class="lineno"> 2098</span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, earl::value::DictFloatIterator&gt;)</div>
<div class="line"><span class="lineno"> 2099</span>                    elements.push_back(std::make_shared&lt;earl::value::Float&gt;(it-&gt;first));</div>
<div class="line"><span class="lineno"> 2100</span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;T, earl::value::DictStrIterator&gt;)</div>
<div class="line"><span class="lineno"> 2101</span>                    elements.push_back(std::make_shared&lt;earl::value::Str&gt;(it-&gt;first));</div>
<div class="line"><span class="lineno"> 2102</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2103</span>                    Err::err_wexpr(stmt-&gt;m_expr.get());</div>
<div class="line"><span class="lineno"> 2104</span>                    <span class="keyword">const</span> std::string msg = <span class="stringliteral">&quot;unknown dictionary iterator type&quot;</span>;</div>
<div class="line"><span class="lineno"> 2105</span>                    <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 2106</span>                }</div>
<div class="line"><span class="lineno"> 2107</span>                elements.push_back(it-&gt;second);</div>
<div class="line"><span class="lineno"> 2108</span>                <span class="keyword">auto</span> tuple = std::make_shared&lt;earl::value::Tuple&gt;(elements);</div>
<div class="line"><span class="lineno"> 2109</span>                handle_enumerators(tuple);</div>
<div class="line"><span class="lineno"> 2110</span>            }</div>
<div class="line"><span class="lineno"> 2111</span>        }, it);</div>
<div class="line"><span class="lineno"> 2112</span>    };</div>
<div class="line"><span class="lineno"> 2113</span> </div>
<div class="line"><span class="lineno"> 2114</span>    <span class="comment">// The container we are iterating over is empty, nothing to do.</span></div>
<div class="line"><span class="lineno"> 2115</span>    <span class="keywordflow">if</span> (wrapped_iterator == wrapped_iterator_end)</div>
<div class="line"><span class="lineno"> 2116</span>        <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno"> 2117</span> </div>
<div class="line"><span class="lineno"> 2118</span>    <span class="comment">// Setup starting enumerators</span></div>
<div class="line"><span class="lineno"> 2119</span>    iterator_reduce(wrapped_iterator, [&amp;](<span class="keyword">auto</span> &amp;tuple){</div>
<div class="line"><span class="lineno"> 2120</span>        destructure_enumerators(stmt-&gt;<a class="code hl_variable" href="structStmtForeach.html#a130042e5e76a23ac76696a5f29604df0">m_enumerators</a>, enumerators, tuple, stmt-&gt;m_attrs, stmt-&gt;m_expr.get());</div>
<div class="line"><span class="lineno"> 2121</span>    });</div>
<div class="line"><span class="lineno"> 2122</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; enumerators.size(); ++i)</div>
<div class="line"><span class="lineno"> 2123</span>        ctx-&gt;variable_add(enumerators[i]);</div>
<div class="line"><span class="lineno"> 2124</span> </div>
<div class="line"><span class="lineno"> 2125</span>    <span class="comment">// Main loop</span></div>
<div class="line"><span class="lineno"> 2126</span>    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><span class="lineno"> 2127</span> </div>
<div class="line"><span class="lineno"> 2128</span>        <span class="comment">// Have we enumerated over all elements?</span></div>
<div class="line"><span class="lineno"> 2129</span>        <span class="keywordflow">if</span> (std::visit([&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;it) {</div>
<div class="line"><span class="lineno"> 2130</span>            <span class="keywordflow">return</span> it == std::get&lt;std::decay_t&lt;<span class="keyword">decltype</span>(it)&gt;&gt;(wrapped_iterator_end);</div>
<div class="line"><span class="lineno"> 2131</span>        }, wrapped_iterator)) {</div>
<div class="line"><span class="lineno"> 2132</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2133</span>        }</div>
<div class="line"><span class="lineno"> 2134</span> </div>
<div class="line"><span class="lineno"> 2135</span>        <span class="comment">// Get new values into the enumerators.</span></div>
<div class="line"><span class="lineno"> 2136</span>        iterator_reduce(wrapped_iterator, [&amp;](<span class="keyword">auto</span> &amp;tuple){reset_enumerators(enumerators, tuple, stmt-&gt;m_expr.get());});</div>
<div class="line"><span class="lineno"> 2137</span>        result = Interpreter::eval_stmt_block(stmt-&gt;<a class="code hl_variable" href="structStmtForeach.html#a8e9da06a68ad1405b682814534bf5db4">m_block</a>.get(), ctx);</div>
<div class="line"><span class="lineno"> 2138</span> </div>
<div class="line"><span class="lineno"> 2139</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a>) {</div>
<div class="line"><span class="lineno"> 2140</span>            result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2141</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2142</span>        }</div>
<div class="line"><span class="lineno"> 2143</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a>) {</div>
<div class="line"><span class="lineno"> 2144</span>            expr-&gt;iter_next(wrapped_iterator);</div>
<div class="line"><span class="lineno"> 2145</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2146</span>        }</div>
<div class="line"><span class="lineno"> 2147</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() != <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d">earl::value::Type::Void</a>)</div>
<div class="line"><span class="lineno"> 2148</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2149</span> </div>
<div class="line"><span class="lineno"> 2150</span>        expr-&gt;iter_next(wrapped_iterator);</div>
<div class="line"><span class="lineno"> 2151</span>    }</div>
<div class="line"><span class="lineno"> 2152</span> </div>
<div class="line"><span class="lineno"> 2153</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; enumerators.size(); ++i)</div>
<div class="line"><span class="lineno"> 2154</span>        ctx-&gt;variable_remove(enumerators[i]-&gt;id());</div>
<div class="line"><span class="lineno"> 2155</span> </div>
<div class="line"><span class="lineno"> 2156</span> done:</div>
<div class="line"><span class="lineno"> 2157</span> </div>
<div class="line"><span class="lineno"> 2158</span>    <span class="keywordflow">if</span> (result &amp;&amp; (result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a> || result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a>))</div>
<div class="line"><span class="lineno"> 2159</span>        result = std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 2160</span> </div>
<div class="line"><span class="lineno"> 2161</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2162</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno"> 2163</span>}</div>
<div class="ttc" id="astructStmtForeach_html_a130042e5e76a23ac76696a5f29604df0"><div class="ttname"><a href="structStmtForeach.html#a130042e5e76a23ac76696a5f29604df0">StmtForeach::m_enumerators</a></div><div class="ttdeci">std::vector&lt; std::shared_ptr&lt; Token &gt; &gt; m_enumerators</div><div class="ttdoc">The identifier of the enumerator variable.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00518">ast.hpp:518</a></div></div>
<div class="ttc" id="astructStmtForeach_html_a8e9da06a68ad1405b682814534bf5db4"><div class="ttname"><a href="structStmtForeach.html#a8e9da06a68ad1405b682814534bf5db4">StmtForeach::m_block</a></div><div class="ttdeci">std::unique_ptr&lt; StmtBlock &gt; m_block</div><div class="ttdoc">The block for the loop to execute.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00523">ast.hpp:523</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a701c83cda284bfe8534e9a9efa65cf23" name="a701c83cda284bfe8534e9a9efa65cf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701c83cda284bfe8534e9a9efa65cf23">&#9670;&nbsp;</a></span>eval_stmt_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtIf.html">StmtIf</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01866">1866</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1866</span>                                                    {</div>
<div class="line"><span class="lineno"> 1867</span>    <span class="keyword">auto</span> er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtIf.html#a6a4068a695ec31cc1c2f7874561e0188">m_expr</a>.get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1868</span>    <span class="keyword">auto</span> condition = unpack_ER(er, ctx, <span class="keyword">true</span>); <span class="comment">// POSSIBLE BREAK, WAS FALSE</span></div>
<div class="line"><span class="lineno"> 1869</span>    std::shared_ptr&lt;earl::value::Obj&gt; result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1870</span> </div>
<div class="line"><span class="lineno"> 1871</span>    <span class="keywordflow">if</span> (condition-&gt;boolean())</div>
<div class="line"><span class="lineno"> 1872</span>        result = Interpreter::eval_stmt_block(stmt-&gt;<a class="code hl_variable" href="structStmtIf.html#af24eb9457dae0cc00159cea729974edd">m_block</a>.get(), ctx);</div>
<div class="line"><span class="lineno"> 1873</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stmt-&gt;<a class="code hl_variable" href="structStmtIf.html#a9582a610a7113e6951ae50e654ab430d">m_else</a>.has_value())</div>
<div class="line"><span class="lineno"> 1874</span>        result = Interpreter::eval_stmt_block(stmt-&gt;<a class="code hl_variable" href="structStmtIf.html#a9582a610a7113e6951ae50e654ab430d">m_else</a>.value().get(), ctx);</div>
<div class="line"><span class="lineno"> 1875</span> </div>
<div class="line"><span class="lineno"> 1876</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1877</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno"> 1878</span>}</div>
<div class="ttc" id="astructStmtIf_html_a6a4068a695ec31cc1c2f7874561e0188"><div class="ttname"><a href="structStmtIf.html#a6a4068a695ec31cc1c2f7874561e0188">StmtIf::m_expr</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_expr</div><div class="ttdoc">The expression that the if evaluates.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00456">ast.hpp:456</a></div></div>
<div class="ttc" id="astructStmtIf_html_a9582a610a7113e6951ae50e654ab430d"><div class="ttname"><a href="structStmtIf.html#a9582a610a7113e6951ae50e654ab430d">StmtIf::m_else</a></div><div class="ttdeci">std::optional&lt; std::unique_ptr&lt; StmtBlock &gt; &gt; m_else</div><div class="ttdoc">The block of the else part of the if statement.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00462">ast.hpp:462</a></div></div>
<div class="ttc" id="astructStmtIf_html_af24eb9457dae0cc00159cea729974edd"><div class="ttname"><a href="structStmtIf.html#af24eb9457dae0cc00159cea729974edd">StmtIf::m_block</a></div><div class="ttdeci">std::unique_ptr&lt; StmtBlock &gt; m_block</div><div class="ttdoc">The block of the statement.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00459">ast.hpp:459</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6759312e77eec73ab603ae88ce11f4d8" name="a6759312e77eec73ab603ae88ce11f4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6759312e77eec73ab603ae88ce11f4d8">&#9670;&nbsp;</a></span>eval_stmt_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_import </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtImport.html">StmtImport</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l02249">2249</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2249</span>                                                            {</div>
<div class="line"><span class="lineno"> 2250</span>    <span class="keywordflow">if</span> (ctx-&gt;type() != CtxType::World) {</div>
<div class="line"><span class="lineno"> 2251</span>        Err::err_wexpr(stmt-&gt;m_fp.get());</div>
<div class="line"><span class="lineno"> 2252</span>        std::string msg = <span class="stringliteral">&quot;`import` statements must be used in the @world context&quot;</span>;</div>
<div class="line"><span class="lineno"> 2253</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 2254</span>    }</div>
<div class="line"><span class="lineno"> 2255</span> </div>
<div class="line"><span class="lineno"> 2256</span>    std::vector&lt;std::string&gt; keywords = COMMON_EARLKW_ASCPL;</div>
<div class="line"><span class="lineno"> 2257</span>    std::vector&lt;std::string&gt; types    = {};</div>
<div class="line"><span class="lineno"> 2258</span>    std::string comment               = COMMON_EARL_COMMENT;</div>
<div class="line"><span class="lineno"> 2259</span> </div>
<div class="line"><span class="lineno"> 2260</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> path_er = eval_expr(stmt-&gt;m_fp.get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 2261</span>    <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp;</div>
<div class="line"><span class="lineno"> 2262</span>    <span class="keyword">auto</span> path_obj                     = unpack_ER(path_er, ctx, &amp;perp);</div>
<div class="line"><span class="lineno"> 2263</span>    std::string path                  = path_obj-&gt;to_cxxstring();</div>
<div class="line"><span class="lineno"> 2264</span>    std::string src_code              = read_file(path.c_str());</div>
<div class="line"><span class="lineno"> 2265</span>    std::unique_ptr&lt;Lexer&gt; lexer      = <a class="code hl_function" href="lexer_8hpp.html#a965016f079674d4a1ddbad67cffe1b8a">lex_file</a>(src_code,</div>
<div class="line"><span class="lineno"> 2266</span>                                                 path,</div>
<div class="line"><span class="lineno"> 2267</span>                                                 keywords,</div>
<div class="line"><span class="lineno"> 2268</span>                                                 types,</div>
<div class="line"><span class="lineno"> 2269</span>                                                 comment);</div>
<div class="line"><span class="lineno"> 2270</span>    std::unique_ptr&lt;Program&gt; program = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2271</span>    <span class="keywordflow">if</span> ((flags &amp; __CHECK) != 0)</div>
<div class="line"><span class="lineno"> 2272</span>        program = <a class="code hl_function" href="namespaceParser.html#a537fc13fc1bf7caa2f5e05ec1a04634c">Parser::parse_program</a>(*lexer.get(), path, <span class="comment">/*from=*/</span><span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;get_filepath());</div>
<div class="line"><span class="lineno"> 2273</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 2274</span>        program = <a class="code hl_function" href="namespaceParser.html#a537fc13fc1bf7caa2f5e05ec1a04634c">Parser::parse_program</a>(*lexer.get(), path);</div>
<div class="line"><span class="lineno"> 2275</span> </div>
<div class="line"><span class="lineno"> 2276</span>    std::shared_ptr&lt;Ctx&gt; child_ctx =</div>
<div class="line"><span class="lineno"> 2277</span>        Interpreter::interpret(std::move(program), std::move(lexer));</div>
<div class="line"><span class="lineno"> 2278</span>    <span class="keywordflow">if</span> (stmt-&gt;m_as.has_value()) {</div>
<div class="line"><span class="lineno"> 2279</span>        <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(child_ctx.get())</div>
<div class="line"><span class="lineno"> 2280</span>            -&gt;set_module_alias(stmt-&gt;m_as.value()-&gt;lexeme());</div>
<div class="line"><span class="lineno"> 2281</span>    }</div>
<div class="line"><span class="lineno"> 2282</span> </div>
<div class="line"><span class="lineno"> 2283</span>    <span class="keywordflow">if</span> (stmt-&gt;__m_depth == COMMON_DEPTH_ALMOST)</div>
<div class="line"><span class="lineno"> 2284</span>        <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(child_ctx.get())-&gt;strip_funs_and_classes();</div>
<div class="line"><span class="lineno"> 2285</span> </div>
<div class="line"><span class="lineno"> 2286</span>    <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;add_import(std::move(child_ctx));</div>
<div class="line"><span class="lineno"> 2287</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2288</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 2289</span>}</div>
<div class="ttc" id="alexer_8hpp_html_a965016f079674d4a1ddbad67cffe1b8a"><div class="ttname"><a href="lexer_8hpp.html#a965016f079674d4a1ddbad67cffe1b8a">lex_file</a></div><div class="ttdeci">std::unique_ptr&lt; Lexer &gt; lex_file(std::string &amp;src_code, std::string fp, std::vector&lt; std::string &gt; &amp;keywords, std::vector&lt; std::string &gt; &amp;types, std::string &amp;comment)</div><div class="ttdoc">Produces a lexer with a list of tokens from the source code of filepath. Any prevalent keywords shoul...</div><div class="ttdef"><b>Definition:</b> <a href="lexer_8cpp_source.html#l00193">lexer.cpp:193</a></div></div>
<div class="ttc" id="anamespaceParser_html_a537fc13fc1bf7caa2f5e05ec1a04634c"><div class="ttname"><a href="namespaceParser.html#a537fc13fc1bf7caa2f5e05ec1a04634c">Parser::parse_program</a></div><div class="ttdeci">std::unique_ptr&lt; Program &gt; parse_program(Lexer &amp;lexer, const std::string filepath, std::string from=&quot;&quot;)</div><div class="ttdoc">The entrypoint to parsing.</div><div class="ttdef"><b>Definition:</b> <a href="parser_8cpp_source.html#l01142">parser.cpp:1142</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9848987fdf8a319ce15dca506de1e360" name="a9848987fdf8a319ce15dca506de1e360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9848987fdf8a319ce15dca506de1e360">&#9670;&nbsp;</a></span>eval_stmt_let()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_let </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtLet.html">StmtLet</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01735">1735</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1735</span>                                                      {</div>
<div class="line"><span class="lineno"> 1736</span>    <span class="keywordflow">if</span> (stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.size() &gt; 1)</div>
<div class="line"><span class="lineno"> 1737</span>        <span class="keywordflow">return</span> eval_stmt_let_wmultiple_vars(stmt, ctx);</div>
<div class="line"><span class="lineno"> 1738</span> </div>
<div class="line"><span class="lineno"> 1739</span>    <span class="keyword">const</span> std::string &amp;<span class="keywordtype">id</span> = stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.at(0)-&gt;lexeme();</div>
<div class="line"><span class="lineno"> 1740</span> </div>
<div class="line"><span class="lineno"> 1741</span>    <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Closure)</div>
<div class="line"><span class="lineno"> 1742</span>        <span class="comment">// Special case for when we declare a variable in a recursive closure.</span></div>
<div class="line"><span class="lineno"> 1743</span>        <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structClosureCtx.html">ClosureCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;assert_variable_does_not_exist_for_recursive_cl(<span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno"> 1744</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1745</span>        <span class="keywordflow">if</span> (ctx-&gt;variable_exists(<span class="keywordtype">id</span>)) {</div>
<div class="line"><span class="lineno"> 1746</span>            std::string msg = <span class="stringliteral">&quot;variable `&quot;</span>+<span class="keywordtype">id</span>+<span class="stringliteral">&quot;` is already declared&quot;</span>;</div>
<div class="line"><span class="lineno"> 1747</span>            <span class="keyword">auto</span> conflict = ctx-&gt;variable_get(<span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno"> 1748</span>            Err::err_wconflict(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.at(0).get(), conflict-&gt;gettok());</div>
<div class="line"><span class="lineno"> 1749</span>            <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1750</span>        }</div>
<div class="line"><span class="lineno"> 1751</span>    }</div>
<div class="line"><span class="lineno"> 1752</span> </div>
<div class="line"><span class="lineno"> 1753</span>    <span class="keywordtype">bool</span> ref = (stmt-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Ref)) != 0;</div>
<div class="line"><span class="lineno"> 1754</span>    <span class="keywordtype">bool</span> _const = (stmt-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Const)) != 0;</div>
<div class="line"><span class="lineno"> 1755</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> rhs = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#ab7df48f121571b52b870f6ba2dbbd0a8">m_expr</a>.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1756</span> </div>
<div class="line"><span class="lineno"> 1757</span>    std::shared_ptr&lt;earl::value::Obj&gt; value = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1758</span> </div>
<div class="line"><span class="lineno"> 1759</span>    <span class="keywordflow">if</span> (!rhs.is_class_instant()) {</div>
<div class="line"><span class="lineno"> 1760</span>        <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp(<span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 1761</span>        <span class="keywordflow">if</span> (rhs.is_list_access() &amp;&amp; !ref)</div>
<div class="line"><span class="lineno"> 1762</span>            value = unpack_ER(rhs, ctx, ref, <span class="comment">/*perp=*/</span>&amp;perp)-&gt;copy();</div>
<div class="line"><span class="lineno"> 1763</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rhs.is_list_access())</div>
<div class="line"><span class="lineno"> 1764</span>            value = unpack_ER(rhs, ctx, ref, <span class="comment">/*perp=*/</span>&amp;perp);</div>
<div class="line"><span class="lineno"> 1765</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1766</span>            value = unpack_ER(rhs, ctx, ref, <span class="comment">/*perp=*/</span>&amp;perp);</div>
<div class="line"><span class="lineno"> 1767</span>    }</div>
<div class="line"><span class="lineno"> 1768</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1769</span>        value = unpack_ER(rhs, ctx, ref);</div>
<div class="line"><span class="lineno"> 1770</span> </div>
<div class="line"><span class="lineno"> 1771</span>    <span class="keywordflow">if</span> ((flags &amp; __SHOWLETS) != 0)</div>
<div class="line"><span class="lineno"> 1772</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;[EARL show-lets] &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; value-&gt;to_cxxstring() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1773</span> </div>
<div class="line"><span class="lineno"> 1774</span>    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == <span class="stringliteral">&quot;_&quot;</span>)</div>
<div class="line"><span class="lineno"> 1775</span>        <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1776</span> </div>
<div class="line"><span class="lineno"> 1777</span>    <span class="keywordflow">if</span> (_const || value-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aafcbeb58fca053cad573bd9efda1dc5b">earl::value::Type::Tuple</a>)</div>
<div class="line"><span class="lineno"> 1778</span>        value-&gt;set_const();</div>
<div class="line"><span class="lineno"> 1779</span> </div>
<div class="line"><span class="lineno"> 1780</span>    <span class="keywordflow">if</span> (stmt-&gt;m_tys.size() &gt; 0)</div>
<div class="line"><span class="lineno"> 1781</span>        typecheck(stmt-&gt;m_tys[0].get(), value.get(), ctx);</div>
<div class="line"><span class="lineno"> 1782</span> </div>
<div class="line"><span class="lineno"> 1783</span>    std::vector&lt;std::string&gt; info_lines(stmt-&gt;m_info);</div>
<div class="line"><span class="lineno"> 1784</span>    std::string info = flatten_info(info_lines);</div>
<div class="line"><span class="lineno"> 1785</span> </div>
<div class="line"><span class="lineno"> 1786</span>    std::shared_ptr&lt;earl::variable::Obj&gt; var</div>
<div class="line"><span class="lineno"> 1787</span>        = std::make_shared&lt;earl::variable::Obj&gt;(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.at(0).get(), value, stmt-&gt;m_attrs, std::move(info));</div>
<div class="line"><span class="lineno"> 1788</span>    ctx-&gt;variable_add(var);</div>
<div class="line"><span class="lineno"> 1789</span>    value-&gt;set_owner(var.get());</div>
<div class="line"><span class="lineno"> 1790</span> </div>
<div class="line"><span class="lineno"> 1791</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1792</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1793</span>}</div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952aafcbeb58fca053cad573bd9efda1dc5b"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aafcbeb58fca053cad573bd9efda1dc5b">earl::value::Type::Tuple</a></div><div class="ttdeci">@ Tuple</div></div>
<div class="ttc" id="astructStmtLet_html_a92c080a1ce1ac5faa6bd89d0c0b012ad"><div class="ttname"><a href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">StmtLet::m_ids</a></div><div class="ttdeci">std::vector&lt; std::shared_ptr&lt; Token &gt; &gt; m_ids</div><div class="ttdoc">The token of the identifer.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00388">ast.hpp:388</a></div></div>
<div class="ttc" id="astructStmtLet_html_ab7df48f121571b52b870f6ba2dbbd0a8"><div class="ttname"><a href="structStmtLet.html#ab7df48f121571b52b870f6ba2dbbd0a8">StmtLet::m_expr</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_expr</div><div class="ttdoc">The expression of the Let Statement.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00393">ast.hpp:393</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abfae56204f9742efb8fa8f4f58e2b061" name="abfae56204f9742efb8fa8f4f58e2b061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfae56204f9742efb8fa8f4f58e2b061">&#9670;&nbsp;</a></span>eval_stmt_let_wmultiple_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_let_wmultiple_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtLet.html">StmtLet</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01650">1650</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1650</span>                                                                     {</div>
<div class="line"><span class="lineno"> 1651</span>    <span class="keywordflow">if</span> (ctx-&gt;type() == CtxType::Closure)</div>
<div class="line"><span class="lineno"> 1652</span>        <span class="comment">// Special case for when we declare a variable in a recursive closure.</span></div>
<div class="line"><span class="lineno"> 1653</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<span class="keywordtype">id</span> : stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>)</div>
<div class="line"><span class="lineno"> 1654</span>            <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structClosureCtx.html">ClosureCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;assert_variable_does_not_exist_for_recursive_cl(id-&gt;lexeme());</div>
<div class="line"><span class="lineno"> 1655</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1656</span>        <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="lineno"> 1657</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;<span class="keywordtype">id</span> : stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>) {</div>
<div class="line"><span class="lineno"> 1658</span>            <span class="keywordflow">if</span> (ctx-&gt;variable_exists(id-&gt;lexeme())) {</div>
<div class="line"><span class="lineno"> 1659</span>                std::string msg = <span class="stringliteral">&quot;variable `&quot;</span>+<span class="keywordtype">id</span>-&gt;lexeme()+<span class="stringliteral">&quot;` is already declared&quot;</span>;</div>
<div class="line"><span class="lineno"> 1660</span>                <span class="keyword">auto</span> conflict = ctx-&gt;variable_get(id-&gt;lexeme());</div>
<div class="line"><span class="lineno"> 1661</span>                Err::err_wconflict(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.at(i).get(), conflict-&gt;gettok());</div>
<div class="line"><span class="lineno"> 1662</span>                <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1663</span>                ++i;</div>
<div class="line"><span class="lineno"> 1664</span>            }</div>
<div class="line"><span class="lineno"> 1665</span>        }</div>
<div class="line"><span class="lineno"> 1666</span>    }</div>
<div class="line"><span class="lineno"> 1667</span> </div>
<div class="line"><span class="lineno"> 1668</span>    <span class="keywordtype">bool</span> ref = (stmt-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Ref)) != 0;</div>
<div class="line"><span class="lineno"> 1669</span>    <span class="keywordtype">bool</span> _const = (stmt-&gt;m_attrs &amp; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(Attr::Const)) != 0;</div>
<div class="line"><span class="lineno"> 1670</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> rhs = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#ab7df48f121571b52b870f6ba2dbbd0a8">m_expr</a>.get(), ctx, ref);</div>
<div class="line"><span class="lineno"> 1671</span> </div>
<div class="line"><span class="lineno"> 1672</span>    std::shared_ptr&lt;earl::value::Obj&gt; value = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1673</span> </div>
<div class="line"><span class="lineno"> 1674</span>    <span class="keywordflow">if</span> (!rhs.is_class_instant()) {</div>
<div class="line"><span class="lineno"> 1675</span>        <a class="code hl_struct" href="structPackedERPreliminary.html">PackedERPreliminary</a> perp(<span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno"> 1676</span>        value = unpack_ER(rhs, ctx, ref, <span class="comment">/*perp=*/</span>&amp;perp);</div>
<div class="line"><span class="lineno"> 1677</span>    }</div>
<div class="line"><span class="lineno"> 1678</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1679</span>        value = unpack_ER(rhs, ctx, ref);</div>
<div class="line"><span class="lineno"> 1680</span> </div>
<div class="line"><span class="lineno"> 1681</span>    <span class="keywordflow">if</span> (value-&gt;type() != <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aafcbeb58fca053cad573bd9efda1dc5b">earl::value::Type::Tuple</a>) {</div>
<div class="line"><span class="lineno"> 1682</span>        Err::err_wexpr(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#ab7df48f121571b52b870f6ba2dbbd0a8">m_expr</a>.get());</div>
<div class="line"><span class="lineno"> 1683</span>        <span class="keyword">const</span> std::string msg = <span class="stringliteral">&quot;cannot declare multiple variables that do not equate to a tuple expression&quot;</span>;</div>
<div class="line"><span class="lineno"> 1684</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1685</span>    }</div>
<div class="line"><span class="lineno"> 1686</span> </div>
<div class="line"><span class="lineno"> 1687</span>    <span class="keyword">auto</span> tuple = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structearl_1_1value_1_1Tuple.html">earl::value::Tuple</a> *<span class="keyword">&gt;</span>(value.get());</div>
<div class="line"><span class="lineno"> 1688</span> </div>
<div class="line"><span class="lineno"> 1689</span>    <span class="keywordflow">if</span> (tuple-&gt;value().size() != stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.size()) {</div>
<div class="line"><span class="lineno"> 1690</span>        Err::err_wexpr(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#ab7df48f121571b52b870f6ba2dbbd0a8">m_expr</a>.get());</div>
<div class="line"><span class="lineno"> 1691</span>        <span class="keyword">const</span> std::string msg =</div>
<div class="line"><span class="lineno"> 1692</span>            <span class="stringliteral">&quot;the number of variables declared (&quot;</span></div>
<div class="line"><span class="lineno"> 1693</span>            +std::to_string(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.size())</div>
<div class="line"><span class="lineno"> 1694</span>            +<span class="stringliteral">&quot;) does not match the size of the tuple expression (&quot;</span></div>
<div class="line"><span class="lineno"> 1695</span>            +std::to_string(tuple-&gt;value().size())</div>
<div class="line"><span class="lineno"> 1696</span>            +<span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><span class="lineno"> 1697</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1698</span>    }</div>
<div class="line"><span class="lineno"> 1699</span> </div>
<div class="line"><span class="lineno"> 1700</span>    <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="lineno"> 1701</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;tok : stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>) {</div>
<div class="line"><span class="lineno"> 1702</span>        <span class="keywordflow">if</span> ((flags &amp; __SHOWLETS) != 0)</div>
<div class="line"><span class="lineno"> 1703</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;[EARL show-lets] &quot;</span></div>
<div class="line"><span class="lineno"> 1704</span>                      &lt;&lt; stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.at(i)-&gt;lexeme()</div>
<div class="line"><span class="lineno"> 1705</span>                      &lt;&lt; <span class="stringliteral">&quot; = &quot;</span></div>
<div class="line"><span class="lineno"> 1706</span>                      &lt;&lt; tuple-&gt;value().at(i)-&gt;to_cxxstring()</div>
<div class="line"><span class="lineno"> 1707</span>                      &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1708</span> </div>
<div class="line"><span class="lineno"> 1709</span>        <span class="keywordflow">if</span> (tok-&gt;lexeme() != <span class="stringliteral">&quot;_&quot;</span>) {</div>
<div class="line"><span class="lineno"> 1710</span>            <span class="keywordflow">if</span> (_const)</div>
<div class="line"><span class="lineno"> 1711</span>                tuple-&gt;value().at(i)-&gt;set_const();</div>
<div class="line"><span class="lineno"> 1712</span> </div>
<div class="line"><span class="lineno"> 1713</span>            <span class="keywordflow">if</span> (stmt-&gt;m_tys.size() != 0)</div>
<div class="line"><span class="lineno"> 1714</span>                typecheck(stmt-&gt;m_tys.at(i).get(), tuple-&gt;value().at(i).get(), ctx);</div>
<div class="line"><span class="lineno"> 1715</span> </div>
<div class="line"><span class="lineno"> 1716</span>            std::vector&lt;std::string&gt; info_lines(stmt-&gt;m_info);</div>
<div class="line"><span class="lineno"> 1717</span>            std::string info = flatten_info(info_lines);</div>
<div class="line"><span class="lineno"> 1718</span> </div>
<div class="line"><span class="lineno"> 1719</span>            std::shared_ptr&lt;earl::variable::Obj&gt; var</div>
<div class="line"><span class="lineno"> 1720</span>                = std::make_shared&lt;earl::variable::Obj&gt;(stmt-&gt;<a class="code hl_variable" href="structStmtLet.html#a92c080a1ce1ac5faa6bd89d0c0b012ad">m_ids</a>.at(i).get(),</div>
<div class="line"><span class="lineno"> 1721</span>                                                        tuple-&gt;value().at(i),</div>
<div class="line"><span class="lineno"> 1722</span>                                                        stmt-&gt;m_attrs,</div>
<div class="line"><span class="lineno"> 1723</span>                                                        std::move(info));</div>
<div class="line"><span class="lineno"> 1724</span>            tuple-&gt;value().at(i)-&gt;set_owner(var.get());</div>
<div class="line"><span class="lineno"> 1725</span>            ctx-&gt;variable_add(var);</div>
<div class="line"><span class="lineno"> 1726</span>        }</div>
<div class="line"><span class="lineno"> 1727</span>        ++i;</div>
<div class="line"><span class="lineno"> 1728</span>    }</div>
<div class="line"><span class="lineno"> 1729</span> </div>
<div class="line"><span class="lineno"> 1730</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1731</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1732</span>}</div>
<div class="ttc" id="astructearl_1_1value_1_1Tuple_html"><div class="ttname"><a href="structearl_1_1value_1_1Tuple.html">earl::value::Tuple</a></div><div class="ttdef"><b>Definition:</b> <a href="earl_8hpp_source.html#l00525">earl.hpp:525</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e863f678741d0d724b4a384c5e2c9f6" name="a3e863f678741d0d724b4a384c5e2c9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e863f678741d0d724b4a384c5e2c9f6">&#9670;&nbsp;</a></span>eval_stmt_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtMatch.html">StmtMatch</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l02318">2318</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2318</span>                                                          {</div>
<div class="line"><span class="lineno"> 2319</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> match_er = Interpreter::eval_expr(stmt-&gt;m_expr.get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2320</span>    <span class="keyword">auto</span> match_value = unpack_ER(match_er, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2321</span> </div>
<div class="line"><span class="lineno"> 2322</span>    <span class="comment">// Go through the branches</span></div>
<div class="line"><span class="lineno"> 2323</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; stmt-&gt;m_branches.size(); ++i) {</div>
<div class="line"><span class="lineno"> 2324</span>        <a class="code hl_struct" href="structStmtMatch_1_1Branch.html">StmtMatch::Branch</a> *branch = stmt-&gt;m_branches[i].get();</div>
<div class="line"><span class="lineno"> 2325</span> </div>
<div class="line"><span class="lineno"> 2326</span>        <span class="comment">// Go through the different expressions that are separated by `|`</span></div>
<div class="line"><span class="lineno"> 2327</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; branch-&gt;m_expr.size(); ++j) {</div>
<div class="line"><span class="lineno"> 2328</span>            std::shared_ptr&lt;earl::value::Obj&gt;</div>
<div class="line"><span class="lineno"> 2329</span>                potential_match = <span class="keyword">nullptr</span>,</div>
<div class="line"><span class="lineno"> 2330</span>                guard = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2331</span> </div>
<div class="line"><span class="lineno"> 2332</span>            <span class="keywordflow">if</span> (branch-&gt;m_expr[j]-&gt;get_type() == ExprType::Term &amp;&amp;</div>
<div class="line"><span class="lineno"> 2333</span>                (<span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprTerm.html">ExprTerm</a> *<span class="keyword">&gt;</span>(branch-&gt;m_expr[j].get())-&gt;<a class="code hl_function" href="structExprTerm.html#a98c099de07ddbb4c35e9331d043d8c71">get_term_type</a>() == ExprTermType::Func_Call)) {</div>
<div class="line"><span class="lineno"> 2334</span> </div>
<div class="line"><span class="lineno"> 2335</span>                <span class="keyword">auto</span> test2 = <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structExprFuncCall.html">ExprFuncCall</a> *<span class="keyword">&gt;</span>(branch-&gt;m_expr[j].get());</div>
<div class="line"><span class="lineno"> 2336</span>                <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> possible_id = Interpreter::eval_expr(test2-&gt;m_left.get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2337</span>                <span class="keyword">const</span> std::string &amp;<span class="keywordtype">id</span> = possible_id.id;</div>
<div class="line"><span class="lineno"> 2338</span>                <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == <span class="stringliteral">&quot;some&quot;</span> &amp;&amp; match_value-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a054b4f3ea543c990f6b125f41af6ebf7">earl::value::Type::Option</a>) {</div>
<div class="line"><span class="lineno"> 2339</span>                    <span class="keyword">auto</span> tmp_var = handle_match_some_branch(test2, match_value, ctx);</div>
<div class="line"><span class="lineno"> 2340</span> </div>
<div class="line"><span class="lineno"> 2341</span>                    <span class="keywordflow">if</span> (tmp_var) {</div>
<div class="line"><span class="lineno"> 2342</span>                        ctx-&gt;variable_add(tmp_var);</div>
<div class="line"><span class="lineno"> 2343</span> </div>
<div class="line"><span class="lineno"> 2344</span>                        <span class="keywordflow">if</span> (branch-&gt;m_when.has_value()) {</div>
<div class="line"><span class="lineno"> 2345</span>                            <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> _guard = Interpreter::eval_expr(branch-&gt;m_when.value().get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2346</span>                            guard = unpack_ER(_guard, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2347</span>                        }</div>
<div class="line"><span class="lineno"> 2348</span> </div>
<div class="line"><span class="lineno"> 2349</span>                        <span class="keywordflow">if</span> (guard == <span class="keyword">nullptr</span> || guard-&gt;boolean()) {</div>
<div class="line"><span class="lineno"> 2350</span>                            <span class="keyword">auto</span> res = Interpreter::eval_stmt_block(branch-&gt;m_block.get(), ctx);</div>
<div class="line"><span class="lineno"> 2351</span>                            ctx-&gt;variable_remove(tmp_var-&gt;id());</div>
<div class="line"><span class="lineno"> 2352</span>                            stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2353</span>                            <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno"> 2354</span>                        }</div>
<div class="line"><span class="lineno"> 2355</span>                        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 2356</span>                            ctx-&gt;variable_remove(tmp_var-&gt;id());</div>
<div class="line"><span class="lineno"> 2357</span>                    }</div>
<div class="line"><span class="lineno"> 2358</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 2359</span>                        <span class="comment">// It is `some`, but it does not have a variable</span></div>
<div class="line"><span class="lineno"> 2360</span>                        <span class="keywordflow">goto</span> not_some;</div>
<div class="line"><span class="lineno"> 2361</span>                }</div>
<div class="line"><span class="lineno"> 2362</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 2363</span>                    <span class="comment">// It is not `some`</span></div>
<div class="line"><span class="lineno"> 2364</span>                    <span class="keywordflow">goto</span> not_some;</div>
<div class="line"><span class="lineno"> 2365</span>            }</div>
<div class="line"><span class="lineno"> 2366</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2367</span>            not_some:</div>
<div class="line"><span class="lineno"> 2368</span>                <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> _potential_match = Interpreter::eval_expr(branch-&gt;m_expr[j].get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2369</span>                potential_match = unpack_ER(_potential_match, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2370</span>                <span class="keywordflow">if</span> (match_value-&gt;eq(potential_match.get()) || potential_match-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d">earl::value::Type::Void</a>) {</div>
<div class="line"><span class="lineno"> 2371</span>                    <span class="keywordflow">if</span> (branch-&gt;m_when.has_value()) {</div>
<div class="line"><span class="lineno"> 2372</span>                        <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> _guard = Interpreter::eval_expr(branch-&gt;m_when.value().get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2373</span>                        guard = unpack_ER(_guard, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 2374</span>                    }</div>
<div class="line"><span class="lineno"> 2375</span>                    <span class="keywordflow">if</span> (guard == <span class="keyword">nullptr</span> || guard-&gt;boolean()) {</div>
<div class="line"><span class="lineno"> 2376</span>                        stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2377</span>                        <span class="keywordflow">return</span> Interpreter::eval_stmt_block(branch-&gt;m_block.get(), ctx);</div>
<div class="line"><span class="lineno"> 2378</span>                    }</div>
<div class="line"><span class="lineno"> 2379</span>                }</div>
<div class="line"><span class="lineno"> 2380</span>            }</div>
<div class="line"><span class="lineno"> 2381</span>        }</div>
<div class="line"><span class="lineno"> 2382</span>    }</div>
<div class="line"><span class="lineno"> 2383</span> </div>
<div class="line"><span class="lineno"> 2384</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2385</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2386</span>}</div>
<div class="ttc" id="anamespaceearl_1_1value_html_a19e41a96be4459b3f8946c8d7ed9f952a054b4f3ea543c990f6b125f41af6ebf7"><div class="ttname"><a href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a054b4f3ea543c990f6b125f41af6ebf7">earl::value::Type::Option</a></div><div class="ttdeci">@ Option</div></div>
<div class="ttc" id="astructExprTerm_html"><div class="ttname"><a href="structExprTerm.html">ExprTerm</a></div><div class="ttdoc">The Expression Term class.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00115">ast.hpp:115</a></div></div>
<div class="ttc" id="astructStmtMatch_1_1Branch_html"><div class="ttname"><a href="structStmtMatch_1_1Branch.html">StmtMatch::Branch</a></div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00599">ast.hpp:599</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c949702d10c60c678d744b95b88a767" name="a9c949702d10c60c678d744b95b88a767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c949702d10c60c678d744b95b88a767">&#9670;&nbsp;</a></span>eval_stmt_mod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_mod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtMod.html">StmtMod</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l02240">2240</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2240</span>                                                      {</div>
<div class="line"><span class="lineno"> 2241</span>    <span class="keywordflow">if</span> ((flags &amp; __VERBOSE) != 0)</div>
<div class="line"><span class="lineno"> 2242</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;[EARL] found module &quot;</span> &lt;&lt; stmt-&gt;m_id-&gt;lexeme() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 2243</span>    <span class="keyword">dynamic_cast&lt;</span><a class="code hl_struct" href="structWorldCtx.html">WorldCtx</a> *<span class="keyword">&gt;</span>(ctx.get())-&gt;set_mod(stmt-&gt;m_id-&gt;lexeme());</div>
<div class="line"><span class="lineno"> 2244</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2245</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 2246</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4757dd52050c9af9135d49de45098eed" name="a4757dd52050c9af9135d49de45098eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4757dd52050c9af9135d49de45098eed">&#9670;&nbsp;</a></span>eval_stmt_mut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_mut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtMut.html">StmtMut</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01900">1900</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1900</span>                                                      {</div>
<div class="line"><span class="lineno"> 1901</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> left_er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtMut.html#aa6c570372f9005e32ea2ced640482f33">m_left</a>.get(), ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1902</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> right_er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtMut.html#a904c07f5ae6cbe191f0e95faeea3bad1">m_right</a>.get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1903</span> </div>
<div class="line"><span class="lineno"> 1904</span>    <span class="keywordflow">if</span> (left_er.is_tuple_access()) {</div>
<div class="line"><span class="lineno"> 1905</span>        Err::err_wexpr(stmt-&gt;<a class="code hl_variable" href="structStmtMut.html#aa6c570372f9005e32ea2ced640482f33">m_left</a>.get());</div>
<div class="line"><span class="lineno"> 1906</span>        Err::err_wexpr(stmt-&gt;<a class="code hl_variable" href="structStmtMut.html#a904c07f5ae6cbe191f0e95faeea3bad1">m_right</a>.get());</div>
<div class="line"><span class="lineno"> 1907</span>        std::string msg = <span class="stringliteral">&quot;cannot mutate tuple type as they are immutable&quot;</span>;</div>
<div class="line"><span class="lineno"> 1908</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1909</span>    }</div>
<div class="line"><span class="lineno"> 1910</span> </div>
<div class="line"><span class="lineno"> 1911</span>    <span class="keyword">auto</span> l = unpack_ER(left_er, ctx, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1912</span>    <span class="keyword">auto</span> r = unpack_ER(right_er, ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1913</span> </div>
<div class="line"><span class="lineno"> 1914</span>    <span class="keywordtype">bool</span> showmuts = (flags &amp; __SHOWMUTS) != 0;</div>
<div class="line"><span class="lineno"> 1915</span> </div>
<div class="line"><span class="lineno"> 1916</span>    <span class="keywordflow">if</span> (showmuts) {</div>
<div class="line"><span class="lineno"> 1917</span>        <span class="keyword">auto</span> lvar_owner = l-&gt;borrow_owner();</div>
<div class="line"><span class="lineno"> 1918</span>        <span class="keyword">auto</span> rvar_owner = r-&gt;borrow_owner();</div>
<div class="line"><span class="lineno"> 1919</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;[EARL show-muts] &quot;</span>;</div>
<div class="line"><span class="lineno"> 1920</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;&lt;&quot;</span> &lt;&lt; (lvar_owner ? lvar_owner-&gt;id() : <span class="stringliteral">&quot;?&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; l-&gt;to_cxxstring();</div>
<div class="line"><span class="lineno"> 1921</span>        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stmt-&gt;m_equals-&gt;lexeme() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 1922</span>        std::cout &lt;&lt; <span class="stringliteral">&quot;&lt;&quot;</span> &lt;&lt; (rvar_owner ? rvar_owner-&gt;id() : <span class="stringliteral">&quot;?&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; r-&gt;to_cxxstring();</div>
<div class="line"><span class="lineno"> 1923</span>    }</div>
<div class="line"><span class="lineno"> 1924</span> </div>
<div class="line"><span class="lineno"> 1925</span>    <span class="keywordflow">switch</span> (stmt-&gt;m_equals-&gt;type()) {</div>
<div class="line"><span class="lineno"> 1926</span>    <span class="keywordflow">case</span> TokenType::Equals: {</div>
<div class="line"><span class="lineno"> 1927</span>        l-&gt;mutate(r.get(), stmt);</div>
<div class="line"><span class="lineno"> 1928</span>        <span class="keywordflow">if</span> (showmuts)</div>
<div class="line"><span class="lineno"> 1929</span>            std::cout &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; l-&gt;to_cxxstring() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1930</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1931</span>    <span class="keywordflow">case</span> TokenType::Plus_Equals:</div>
<div class="line"><span class="lineno"> 1932</span>    <span class="keywordflow">case</span> TokenType::Minus_Equals:</div>
<div class="line"><span class="lineno"> 1933</span>    <span class="keywordflow">case</span> TokenType::Asterisk_Equals:</div>
<div class="line"><span class="lineno"> 1934</span>    <span class="keywordflow">case</span> TokenType::Forwardslash_Equals:</div>
<div class="line"><span class="lineno"> 1935</span>    <span class="keywordflow">case</span> TokenType::Percent_Equals:</div>
<div class="line"><span class="lineno"> 1936</span>    <span class="keywordflow">case</span> TokenType::Backtick_Pipe_Equals:</div>
<div class="line"><span class="lineno"> 1937</span>    <span class="keywordflow">case</span> TokenType::Backtick_Ampersand_Equals:</div>
<div class="line"><span class="lineno"> 1938</span>    <span class="keywordflow">case</span> TokenType::Backtick_Caret_Equals: {</div>
<div class="line"><span class="lineno"> 1939</span>        l-&gt;spec_mutate(stmt-&gt;m_equals.get(), r.get(), stmt);</div>
<div class="line"><span class="lineno"> 1940</span>        <span class="keywordflow">if</span> (showmuts)</div>
<div class="line"><span class="lineno"> 1941</span>            std::cout &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; l-&gt;to_cxxstring() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1942</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1943</span>    <span class="keywordflow">default</span>: {</div>
<div class="line"><span class="lineno"> 1944</span>        Err::err_wtok(stmt-&gt;m_equals.get());</div>
<div class="line"><span class="lineno"> 1945</span>        std::string msg = <span class="stringliteral">&quot;invalid mutation operation `&quot;</span>+stmt-&gt;m_equals-&gt;lexeme()+<span class="stringliteral">&quot;`&quot;</span>;</div>
<div class="line"><span class="lineno"> 1946</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classInterpreterException.html">InterpreterException</a>(msg);</div>
<div class="line"><span class="lineno"> 1947</span>    } <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1948</span>    }</div>
<div class="line"><span class="lineno"> 1949</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1950</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1951</span>}</div>
<div class="ttc" id="astructStmtMut_html_a904c07f5ae6cbe191f0e95faeea3bad1"><div class="ttname"><a href="structStmtMut.html#a904c07f5ae6cbe191f0e95faeea3bad1">StmtMut::m_right</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_right</div><div class="ttdoc">The expression of the right hand side.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00436">ast.hpp:436</a></div></div>
<div class="ttc" id="astructStmtMut_html_aa6c570372f9005e32ea2ced640482f33"><div class="ttname"><a href="structStmtMut.html#aa6c570372f9005e32ea2ced640482f33">StmtMut::m_left</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_left</div><div class="ttdoc">The expression of the left hand side.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00433">ast.hpp:433</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af1324d385847c4f361260ce4f5768fd0" name="af1324d385847c4f361260ce4f5768fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1324d385847c4f361260ce4f5768fd0">&#9670;&nbsp;</a></span>eval_stmt_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtReturn.html">StmtReturn</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01881">1881</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1881</span>                                                            {</div>
<div class="line"><span class="lineno"> 1882</span>    <span class="keywordflow">if</span> (stmt-&gt;<a class="code hl_variable" href="structStmtReturn.html#aaa44e0ef9afc28ea750b1efd6669bf7b">m_expr</a>.has_value()) {</div>
<div class="line"><span class="lineno"> 1883</span>        <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtReturn.html#aaa44e0ef9afc28ea750b1efd6669bf7b">m_expr</a>.value().get(), ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1884</span>        stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1885</span>        <span class="keywordflow">return</span> unpack_ER(er, ctx, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1886</span>    }</div>
<div class="line"><span class="lineno"> 1887</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1888</span>    <span class="keywordflow">return</span> std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1889</span>}</div>
<div class="ttc" id="astructStmtReturn_html_aaa44e0ef9afc28ea750b1efd6669bf7b"><div class="ttname"><a href="structStmtReturn.html#aaa44e0ef9afc28ea750b1efd6669bf7b">StmtReturn::m_expr</a></div><div class="ttdeci">std::optional&lt; std::unique_ptr&lt; Expr &gt; &gt; m_expr</div><div class="ttdoc">The expression that the Statement Return is returning.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00474">ast.hpp:474</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0b5b83c404a3fc36587fcb97d9e0e228" name="a0b5b83c404a3fc36587fcb97d9e0e228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5b83c404a3fc36587fcb97d9e0e228">&#9670;&nbsp;</a></span>eval_stmt_while()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structearl_1_1value_1_1Obj.html">earl::value::Obj</a> &gt; eval_stmt_while </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structStmtWhile.html">StmtWhile</a> *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structCtx.html">Ctx</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="interpreter_8cpp_source.html#l01954">1954</a> of file <a class="el" href="interpreter_8cpp_source.html">interpreter.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1954</span>                                                          {</div>
<div class="line"><span class="lineno"> 1955</span>    std::shared_ptr&lt;earl::value::Obj&gt;</div>
<div class="line"><span class="lineno"> 1956</span>        expr_result = <span class="keyword">nullptr</span>,</div>
<div class="line"><span class="lineno"> 1957</span>        result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1958</span> </div>
<div class="line"><span class="lineno"> 1959</span>    <a class="code hl_struct" href="structInterpreter_1_1ER.html">ER</a> expr_er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtWhile.html#a69c37a6f1da098ed8d7ba2c82f11084e">m_expr</a>.get(), ctx, <span class="comment">/*ref=*/</span><span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1960</span>    expr_result = unpack_ER(expr_er, ctx, <span class="comment">/*ref=*/</span><span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1961</span> </div>
<div class="line"><span class="lineno"> 1962</span>    <span class="keywordflow">while</span> (expr_result-&gt;boolean()) {</div>
<div class="line"><span class="lineno"> 1963</span>        result = Interpreter::eval_stmt_block(stmt-&gt;<a class="code hl_variable" href="structStmtWhile.html#a1a9741fef9ef2d30f0c685ff565973f3">m_block</a>.get(), ctx);</div>
<div class="line"><span class="lineno"> 1964</span> </div>
<div class="line"><span class="lineno"> 1965</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a>) {</div>
<div class="line"><span class="lineno"> 1966</span>            result = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 1967</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1968</span>        }</div>
<div class="line"><span class="lineno"> 1969</span> </div>
<div class="line"><span class="lineno"> 1970</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a>)</div>
<div class="line"><span class="lineno"> 1971</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1972</span> </div>
<div class="line"><span class="lineno"> 1973</span>        <span class="keywordflow">if</span> (result &amp;&amp; result-&gt;type() != <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952a81ceb48a978444906d80119200aa358d">earl::value::Type::Void</a>) {</div>
<div class="line"><span class="lineno"> 1974</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1975</span>        }</div>
<div class="line"><span class="lineno"> 1976</span> </div>
<div class="line"><span class="lineno"> 1977</span>        expr_er = Interpreter::eval_expr(stmt-&gt;<a class="code hl_variable" href="structStmtWhile.html#a69c37a6f1da098ed8d7ba2c82f11084e">m_expr</a>.get(), ctx, <span class="comment">/*ref=*/</span><span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1978</span>        expr_result = unpack_ER(expr_er, ctx, <span class="comment">/*ref=*/</span><span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1979</span>        <span class="keywordflow">if</span> (!expr_result-&gt;boolean())</div>
<div class="line"><span class="lineno"> 1980</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1981</span>    }</div>
<div class="line"><span class="lineno"> 1982</span> </div>
<div class="line"><span class="lineno"> 1983</span>    <span class="keywordflow">if</span> (result &amp;&amp; (result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952aa0bfb8e59e6c13fc8d990781f77694fe">earl::value::Type::Continue</a> || result-&gt;type() == <a class="code hl_enumvalue" href="namespaceearl_1_1value.html#a19e41a96be4459b3f8946c8d7ed9f952ae4c38d6d45baf080943d323dd51a2ce8">earl::value::Type::Break</a>))</div>
<div class="line"><span class="lineno"> 1984</span>        result = std::make_shared&lt;earl::value::Void&gt;();</div>
<div class="line"><span class="lineno"> 1985</span> </div>
<div class="line"><span class="lineno"> 1986</span>    stmt-&gt;m_evald = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1987</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno"> 1988</span>}</div>
<div class="ttc" id="astructStmtWhile_html_a1a9741fef9ef2d30f0c685ff565973f3"><div class="ttname"><a href="structStmtWhile.html#a1a9741fef9ef2d30f0c685ff565973f3">StmtWhile::m_block</a></div><div class="ttdeci">std::unique_ptr&lt; StmtBlock &gt; m_block</div><div class="ttdoc">The block of the while loop to loop.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00501">ast.hpp:501</a></div></div>
<div class="ttc" id="astructStmtWhile_html_a69c37a6f1da098ed8d7ba2c82f11084e"><div class="ttname"><a href="structStmtWhile.html#a69c37a6f1da098ed8d7ba2c82f11084e">StmtWhile::m_expr</a></div><div class="ttdeci">std::unique_ptr&lt; Expr &gt; m_expr</div><div class="ttdoc">The expression to loop while it is true.</div><div class="ttdef"><b>Definition:</b> <a href="ast_8hpp_source.html#l00498">ast.hpp:498</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
